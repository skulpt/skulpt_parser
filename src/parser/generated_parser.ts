// @generated by pegen from ../cpython/Grammar/python.gram
// deno-lint-ignore-file camelcase no-unused-vars

import type {
    mod,
    expr,
    stmt,
    alias,
    withitem,
    excepthandler,
    arguments_,
    arg,
    comprehension,
    Name,
    Call,
    ClassDef,
    FunctionDef,
    AsyncFunctionDef,
    Starred,
} from "../ast/astnodes.ts";
import type { Tokenizer } from "../tokenize/Tokenizer.ts";
import type { TokenInfo } from "../tokenize/tokenize.ts";
import * as astnodes from "../ast/astnodes.ts";
import { pyNone, pyTrue, pyFalse, pyEllipsis } from "../ast/constants.ts";
import {
    StartRule,
    CmpopExprPair,
    KeyValuePair,
    KeywordToken,
    KeywordOrStarred,
    NameDefaultPair,
    SlashWithDefault,
    StarEtc,
    AugOperator,
    STAR_TARGETS,
    DEL_TARGETS,
    FOR_TARGETS,
} from "./pegen_types.ts";
import * as pegen from "./pegen.ts";
import { FILE_INPUT, SINGLE_INPUT, EVAL_INPUT, FUNC_TYPE_INPUT, FSTRING_INPUT } from "./pegen_types.ts";
import { pySyntaxError, pyIndentationError } from "../ast/errors.ts";

import { memoize, memoizeLeftRec, logger, Parser } from "./parser.ts";

/** @todo */
function CHECK<A>(...args: A[]) {
    return args[0];
}

/** @todo */
function CHECK_VERSION<R>(i: number, msg: string, ret: R) {
    return ret;
}

/** @todo */
function CHECK_NULL_ALLOWED<R>(result: R) {
    return result;
}

export class GeneratedParser extends Parser {
    start_rule: StartRule;
    flags: number;

    constructor(T: Tokenizer, start_rule: StartRule = FILE_INPUT, flags = 0) {
        super(T);
        this.start_rule = start_rule;
        this.flags = flags; // unused
    }

    parse(): mod | expr {
        let ret = null;
        switch (this.start_rule) {
            case FILE_INPUT:
                ret = this.file();
                break;
            case SINGLE_INPUT:
                ret = this.interactive();
                break;
            case EVAL_INPUT:
                ret = this.eval();
                break;
            case FUNC_TYPE_INPUT:
                ret = this.func_type();
                break;
            case FSTRING_INPUT:
                ret = this.fstring();
                break;
        }
        if (ret === null) {
            return this.make_syntax_error();
        }
        return ret;
    }

    @memoize
    file(): mod | null {
        // file: statements? $
        let a, endmarker;
        const mark = this.mark();
        if (((a = this.statements()), 1) && (endmarker = this.expect("ENDMARKER"))) {
            return pegen.make_module(this, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    interactive(): mod | null {
        // interactive: statement_newline
        let a;
        const mark = this.mark();
        if ((a = this.statement_newline())) {
            return new astnodes.Interactive(a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    eval(): mod | null {
        // eval: expressions NEWLINE* $
        let _loop0_1, a, endmarker;
        const mark = this.mark();
        if ((a = this.expressions()) && (_loop0_1 = this._loop0_1()) && (endmarker = this.expect("ENDMARKER"))) {
            return new astnodes.Expression(a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    func_type(): mod | null {
        // func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
        let _loop0_2, a, b, endmarker, literal, literal_1, literal_2;
        const mark = this.mark();
        if (
            (literal = this.expect("(")) &&
            ((a = this.type_expressions()), 1) &&
            (literal_1 = this.expect(")")) &&
            (literal_2 = this.expect("->")) &&
            (b = this.expression()) &&
            (_loop0_2 = this._loop0_2()) &&
            (endmarker = this.expect("ENDMARKER"))
        ) {
            return new astnodes.FunctionType(a, b);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    fstring(): expr | null {
        // fstring: star_expressions
        let star_expressions;
        const mark = this.mark();
        if ((star_expressions = this.star_expressions())) {
            return star_expressions;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    type_expressions(): expr[] | null {
        // type_expressions: ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+
        let _gather_9, a, b, c, literal, literal_1, literal_2, literal_3;
        const mark = this.mark();
        if (
            (a = this._gather_3()) &&
            (literal = this.expect(",")) &&
            (literal_1 = this.expect("*")) &&
            (b = this.expression()) &&
            (literal_2 = this.expect(",")) &&
            (literal_3 = this.expect("**")) &&
            (c = this.expression())
        ) {
            return pegen.seq_append_to_end(this, CHECK(pegen.seq_append_to_end(this, a, b)), c);
        }
        this.reset(mark);
        if (
            (a = this._gather_5()) &&
            (literal = this.expect(",")) &&
            (literal_1 = this.expect("*")) &&
            (b = this.expression())
        ) {
            return pegen.seq_append_to_end(this, a, b);
        }
        this.reset(mark);
        if (
            (a = this._gather_7()) &&
            (literal = this.expect(",")) &&
            (literal_1 = this.expect("**")) &&
            (b = this.expression())
        ) {
            return pegen.seq_append_to_end(this, a, b);
        }
        this.reset(mark);
        if (
            (literal = this.expect("*")) &&
            (a = this.expression()) &&
            (literal_1 = this.expect(",")) &&
            (literal_2 = this.expect("**")) &&
            (b = this.expression())
        ) {
            return pegen.seq_append_to_end(this, CHECK(pegen.singleton_seq(this, a)), b);
        }
        this.reset(mark);
        if ((literal = this.expect("*")) && (a = this.expression())) {
            return pegen.singleton_seq(this, a);
        }
        this.reset(mark);
        if ((literal = this.expect("**")) && (a = this.expression())) {
            return pegen.singleton_seq(this, a);
        }
        this.reset(mark);
        if ((_gather_9 = this._gather_9())) {
            return _gather_9;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    statements(): stmt[] | null {
        // statements: statement+
        let a;
        const mark = this.mark();
        if ((a = this._loop1_11())) {
            return pegen.seq_flatten(this, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    statement(): stmt[] | null {
        // statement: compound_stmt | simple_stmt
        let a, simple_stmt;
        const mark = this.mark();
        if ((a = this.compound_stmt())) {
            return pegen.singleton_seq(this, a);
        }
        this.reset(mark);
        if ((simple_stmt = this.simple_stmt())) {
            return simple_stmt;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    statement_newline(): stmt[] | null {
        // statement_newline: compound_stmt NEWLINE | simple_stmt | NEWLINE | $
        let a, endmarker, newline, simple_stmt;
        const mark = this.mark();
        if ((a = this.compound_stmt()) && (newline = this.expect("NEWLINE"))) {
            return pegen.singleton_seq(this, a);
        }
        this.reset(mark);
        if ((simple_stmt = this.simple_stmt())) {
            return simple_stmt;
        }
        this.reset(mark);
        if ((newline = this.expect("NEWLINE"))) {
            const EXTRA = this.extra(mark);
            return pegen.singleton_seq(this, CHECK(new astnodes.Pass(...EXTRA)));
        }
        this.reset(mark);
        if ((endmarker = this.expect("ENDMARKER"))) {
            return pegen.interactive_exit(this);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    simple_stmt(): stmt[] | null {
        // simple_stmt: small_stmt !';' NEWLINE | ';'.small_stmt+ ';'? NEWLINE
        let a, newline, opt;
        const mark = this.mark();
        if (
            (a = this.small_stmt()) &&
            this.negative_lookahead(this.expect, ";") &&
            (newline = this.expect("NEWLINE"))
        ) {
            return pegen.singleton_seq(this, a);
        }
        this.reset(mark);
        if ((a = this._gather_12()) && ((opt = this.expect(";")), 1) && (newline = this.expect("NEWLINE"))) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    small_stmt(): stmt | null {
        // small_stmt: assignment | star_expressions | &'return' return_stmt | &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del' del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' | 'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt
        let assert_stmt,
            assignment,
            del_stmt,
            e,
            global_stmt,
            import_stmt,
            keyword,
            nonlocal_stmt,
            raise_stmt,
            return_stmt,
            yield_stmt;
        const mark = this.mark();
        if ((assignment = this.assignment())) {
            return assignment;
        }
        this.reset(mark);
        if ((e = this.star_expressions())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Expr(e, ...EXTRA);
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "return") && (return_stmt = this.return_stmt())) {
            return return_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this._tmp_14) && (import_stmt = this.import_stmt())) {
            return import_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "raise") && (raise_stmt = this.raise_stmt())) {
            return raise_stmt;
        }
        this.reset(mark);
        if ((keyword = this.expect("pass"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Pass(...EXTRA);
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "del") && (del_stmt = this.del_stmt())) {
            return del_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "yield") && (yield_stmt = this.yield_stmt())) {
            return yield_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "assert") && (assert_stmt = this.assert_stmt())) {
            return assert_stmt;
        }
        this.reset(mark);
        if ((keyword = this.expect("break"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Break(...EXTRA);
        }
        this.reset(mark);
        if ((keyword = this.expect("continue"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Continue(...EXTRA);
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "global") && (global_stmt = this.global_stmt())) {
            return global_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "nonlocal") && (nonlocal_stmt = this.nonlocal_stmt())) {
            return nonlocal_stmt;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    compound_stmt(): stmt | null {
        // compound_stmt: &('def' | '@' | ASYNC) function_def | &'if' if_stmt | &('class' | '@') class_def | &('with' | ASYNC) with_stmt | &('for' | ASYNC) for_stmt | &'try' try_stmt | &'while' while_stmt
        let class_def, for_stmt, function_def, if_stmt, try_stmt, while_stmt, with_stmt;
        const mark = this.mark();
        if (this.positive_lookahead(this._tmp_15) && (function_def = this.function_def())) {
            return function_def;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "if") && (if_stmt = this.if_stmt())) {
            return if_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this._tmp_16) && (class_def = this.class_def())) {
            return class_def;
        }
        this.reset(mark);
        if (this.positive_lookahead(this._tmp_17) && (with_stmt = this.with_stmt())) {
            return with_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this._tmp_18) && (for_stmt = this.for_stmt())) {
            return for_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "try") && (try_stmt = this.try_stmt())) {
            return try_stmt;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "while") && (while_stmt = this.while_stmt())) {
            return while_stmt;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    assignment(): stmt | null {
        // assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT? | single_target augassign ~ (yield_expr | star_expressions) | invalid_assignment
        let a, b, c, invalid_assignment, literal, tc;
        let cut = false;
        const mark = this.mark();
        if (
            (a = this.name()) &&
            (literal = this.expect(":")) &&
            (b = this.expression()) &&
            ((c = this._tmp_19()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return CHECK_VERSION(
                6,
                "Variable annotation syntax is",
                new astnodes.AnnAssign(CHECK(pegen.set_expr_context(this, a, astnodes.Store)), b, c, 1, ...EXTRA)
            );
        }
        this.reset(mark);
        if (
            (a = this._tmp_20()) &&
            (literal = this.expect(":")) &&
            (b = this.expression()) &&
            ((c = this._tmp_21()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return CHECK_VERSION(6, "Variable annotations syntax is", new astnodes.AnnAssign(a, b, c, 0, ...EXTRA));
        }
        this.reset(mark);
        if (
            (a = this._loop1_22()) &&
            (b = this._tmp_23()) &&
            this.negative_lookahead(this.expect, "=") &&
            ((tc = this.expect("TYPE_COMMENT")), 1)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Assign(a, b, pegen.NEW_TYPE_COMMENT(this, tc), ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.single_target()) && (b = this.augassign()) && (cut = true) && (c = this._tmp_24())) {
            const EXTRA = this.extra(mark);
            return new astnodes.AugAssign(a, b.kind, c, ...EXTRA);
        }
        this.reset(mark);
        if (cut) return null;
        if ((invalid_assignment = this.invalid_assignment())) {
            return invalid_assignment;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    augassign(): AugOperator | null {
        // augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        let literal;
        const mark = this.mark();
        if ((literal = this.expect("+="))) {
            return new AugOperator(astnodes.Add);
        }
        this.reset(mark);
        if ((literal = this.expect("-="))) {
            return new AugOperator(astnodes.Sub);
        }
        this.reset(mark);
        if ((literal = this.expect("*="))) {
            return new AugOperator(astnodes.Mult);
        }
        this.reset(mark);
        if ((literal = this.expect("@="))) {
            return CHECK_VERSION(5, "The '@' operator is", new AugOperator(astnodes.MatMult));
        }
        this.reset(mark);
        if ((literal = this.expect("/="))) {
            return new AugOperator(astnodes.Div);
        }
        this.reset(mark);
        if ((literal = this.expect("%="))) {
            return new AugOperator(astnodes.Mod);
        }
        this.reset(mark);
        if ((literal = this.expect("&="))) {
            return new AugOperator(astnodes.BitAnd);
        }
        this.reset(mark);
        if ((literal = this.expect("|="))) {
            return new AugOperator(astnodes.BitOr);
        }
        this.reset(mark);
        if ((literal = this.expect("^="))) {
            return new AugOperator(astnodes.BitXor);
        }
        this.reset(mark);
        if ((literal = this.expect("<<="))) {
            return new AugOperator(astnodes.LShift);
        }
        this.reset(mark);
        if ((literal = this.expect(">>="))) {
            return new AugOperator(astnodes.RShift);
        }
        this.reset(mark);
        if ((literal = this.expect("**="))) {
            return new AugOperator(astnodes.Pow);
        }
        this.reset(mark);
        if ((literal = this.expect("//="))) {
            return new AugOperator(astnodes.FloorDiv);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    global_stmt(): stmt | null {
        // global_stmt: 'global' ','.NAME+
        let a, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("global")) && (a = this._gather_25())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Global(CHECK(pegen.map_names_to_ids(this, a)), ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    nonlocal_stmt(): stmt | null {
        // nonlocal_stmt: 'nonlocal' ','.NAME+
        let a, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("nonlocal")) && (a = this._gather_27())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Nonlocal(CHECK(pegen.map_names_to_ids(this, a)), ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    yield_stmt(): stmt | null {
        // yield_stmt: yield_expr
        let y;
        const mark = this.mark();
        if ((y = this.yield_expr())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Expr(y, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    assert_stmt(): stmt | null {
        // assert_stmt: 'assert' expression [',' expression]
        let a, b, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("assert")) && (a = this.expression()) && ((b = this._tmp_29()), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Assert(a, b, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    del_stmt(): stmt | null {
        // del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
        let a, invalid_del_stmt, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("del")) && (a = this.del_targets()) && this.positive_lookahead(this._tmp_30)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Delete(a, ...EXTRA);
        }
        this.reset(mark);
        if ((invalid_del_stmt = this.invalid_del_stmt())) {
            return invalid_del_stmt;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    import_stmt(): stmt | null {
        // import_stmt: import_name | import_from
        let import_from, import_name;
        const mark = this.mark();
        if ((import_name = this.import_name())) {
            return import_name;
        }
        this.reset(mark);
        if ((import_from = this.import_from())) {
            return import_from;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    import_name(): stmt | null {
        // import_name: 'import' dotted_as_names
        let a, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("import")) && (a = this.dotted_as_names())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Import(a, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    import_from(): stmt | null {
        // import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets
        let a, b, c, keyword, keyword_1;
        const mark = this.mark();
        if (
            (keyword = this.expect("from")) &&
            (a = this._loop0_31()) &&
            (b = this.dotted_name()) &&
            (keyword_1 = this.expect("import")) &&
            (c = this.import_from_targets())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.ImportFrom(b.id, c, pegen.seq_count_dots(a), ...EXTRA);
        }
        this.reset(mark);
        if (
            (keyword = this.expect("from")) &&
            (a = this._loop1_32()) &&
            (keyword_1 = this.expect("import")) &&
            (b = this.import_from_targets())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.ImportFrom(null, b, pegen.seq_count_dots(a), ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    import_from_targets(): alias[] | null {
        // import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names !',' | '*' | invalid_import_from_targets
        let a, import_from_as_names, invalid_import_from_targets, literal, literal_1, opt;
        const mark = this.mark();
        if (
            (literal = this.expect("(")) &&
            (a = this.import_from_as_names()) &&
            ((opt = this.expect(",")), 1) &&
            (literal_1 = this.expect(")"))
        ) {
            return a;
        }
        this.reset(mark);
        if ((import_from_as_names = this.import_from_as_names()) && this.negative_lookahead(this.expect, ",")) {
            return import_from_as_names;
        }
        this.reset(mark);
        if ((literal = this.expect("*"))) {
            return pegen.singleton_seq(this, CHECK(pegen.alias_for_star(this)));
        }
        this.reset(mark);
        if ((invalid_import_from_targets = this.invalid_import_from_targets())) {
            return invalid_import_from_targets;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    import_from_as_names(): alias[] | null {
        // import_from_as_names: ','.import_from_as_name+
        let a;
        const mark = this.mark();
        if ((a = this._gather_33())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    import_from_as_name(): alias | null {
        // import_from_as_name: NAME ['as' NAME]
        let a, b;
        const mark = this.mark();
        if ((a = this.name()) && ((b = this._tmp_35()), 1)) {
            return new astnodes.alias(a.id, b ? b.id : null);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    dotted_as_names(): alias[] | null {
        // dotted_as_names: ','.dotted_as_name+
        let a;
        const mark = this.mark();
        if ((a = this._gather_36())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    dotted_as_name(): alias | null {
        // dotted_as_name: dotted_name ['as' NAME]
        let a, b;
        const mark = this.mark();
        if ((a = this.dotted_name()) && ((b = this._tmp_38()), 1)) {
            return new astnodes.alias(a.id, b ? b.id : null);
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    dotted_name(): Name | null {
        // dotted_name: dotted_name '.' NAME | NAME
        let a, b, literal, name;
        const mark = this.mark();
        if ((a = this.dotted_name()) && (literal = this.expect(".")) && (b = this.name())) {
            return pegen.join_names_with_dot(this, a, b);
        }
        this.reset(mark);
        if ((name = this.name())) {
            return name;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    if_stmt(): stmt | null {
        // if_stmt: 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block else_block?
        let a, b, c, keyword, literal;
        const mark = this.mark();
        if (
            (keyword = this.expect("if")) &&
            (a = this.named_expression()) &&
            (literal = this.expect(":")) &&
            (b = this.block()) &&
            (c = this.elif_stmt())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.If(a, b, CHECK(pegen.singleton_seq(this, c)), ...EXTRA);
        }
        this.reset(mark);
        if (
            (keyword = this.expect("if")) &&
            (a = this.named_expression()) &&
            (literal = this.expect(":")) &&
            (b = this.block()) &&
            ((c = this.else_block()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.If(a, b, c, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    elif_stmt(): stmt | null {
        // elif_stmt: 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block else_block?
        let a, b, c, keyword, literal;
        const mark = this.mark();
        if (
            (keyword = this.expect("elif")) &&
            (a = this.named_expression()) &&
            (literal = this.expect(":")) &&
            (b = this.block()) &&
            (c = this.elif_stmt())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.If(a, b, CHECK(pegen.singleton_seq(this, c)), ...EXTRA);
        }
        this.reset(mark);
        if (
            (keyword = this.expect("elif")) &&
            (a = this.named_expression()) &&
            (literal = this.expect(":")) &&
            (b = this.block()) &&
            ((c = this.else_block()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.If(a, b, c, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    else_block(): stmt[] | null {
        // else_block: 'else' ':' block
        let b, keyword, literal;
        const mark = this.mark();
        if ((keyword = this.expect("else")) && (literal = this.expect(":")) && (b = this.block())) {
            return b;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    while_stmt(): stmt | null {
        // while_stmt: 'while' named_expression ':' block else_block?
        let a, b, c, keyword, literal;
        const mark = this.mark();
        if (
            (keyword = this.expect("while")) &&
            (a = this.named_expression()) &&
            (literal = this.expect(":")) &&
            (b = this.block()) &&
            ((c = this.else_block()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.While(a, b, c, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    for_stmt(): stmt | null {
        // for_stmt: 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | invalid_for_target
        let async, b, el, ex, invalid_for_target, keyword, keyword_1, literal, t, tc;
        let cut = false;
        const mark = this.mark();
        if (
            (keyword = this.expect("for")) &&
            (t = this.star_targets()) &&
            (keyword_1 = this.expect("in")) &&
            (cut = true) &&
            (ex = this.star_expressions()) &&
            (literal = this.expect(":")) &&
            ((tc = this.expect("TYPE_COMMENT")), 1) &&
            (b = this.block()) &&
            ((el = this.else_block()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.For(t, ex, b, el, pegen.NEW_TYPE_COMMENT(this, tc), ...EXTRA);
        }
        this.reset(mark);
        if (cut) return null;
        if (
            (async = this.expect("ASYNC")) &&
            (keyword = this.expect("for")) &&
            (t = this.star_targets()) &&
            (keyword_1 = this.expect("in")) &&
            (cut = true) &&
            (ex = this.star_expressions()) &&
            (literal = this.expect(":")) &&
            ((tc = this.expect("TYPE_COMMENT")), 1) &&
            (b = this.block()) &&
            ((el = this.else_block()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return CHECK_VERSION(
                5,
                "Async for loops are",
                new astnodes.AsyncFor(t, ex, b, el, pegen.NEW_TYPE_COMMENT(this, tc), ...EXTRA)
            );
        }
        this.reset(mark);
        if (cut) return null;
        if ((invalid_for_target = this.invalid_for_target())) {
            return invalid_for_target;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    with_stmt(): stmt | null {
        // with_stmt: 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' TYPE_COMMENT? block | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
        let a, async, b, keyword, literal, literal_1, literal_2, opt, tc;
        const mark = this.mark();
        if (
            (keyword = this.expect("with")) &&
            (literal = this.expect("(")) &&
            (a = this._gather_39()) &&
            ((opt = this.expect(",")), 1) &&
            (literal_1 = this.expect(")")) &&
            (literal_2 = this.expect(":")) &&
            (b = this.block())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.With(a, b, null, ...EXTRA);
        }
        this.reset(mark);
        if (
            (keyword = this.expect("with")) &&
            (a = this._gather_41()) &&
            (literal = this.expect(":")) &&
            ((tc = this.expect("TYPE_COMMENT")), 1) &&
            (b = this.block())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.With(a, b, pegen.NEW_TYPE_COMMENT(this, tc), ...EXTRA);
        }
        this.reset(mark);
        if (
            (async = this.expect("ASYNC")) &&
            (keyword = this.expect("with")) &&
            (literal = this.expect("(")) &&
            (a = this._gather_43()) &&
            ((opt = this.expect(",")), 1) &&
            (literal_1 = this.expect(")")) &&
            (literal_2 = this.expect(":")) &&
            (b = this.block())
        ) {
            const EXTRA = this.extra(mark);
            return CHECK_VERSION(5, "Async with statements are", new astnodes.AsyncWith(a, b, null, ...EXTRA));
        }
        this.reset(mark);
        if (
            (async = this.expect("ASYNC")) &&
            (keyword = this.expect("with")) &&
            (a = this._gather_45()) &&
            (literal = this.expect(":")) &&
            ((tc = this.expect("TYPE_COMMENT")), 1) &&
            (b = this.block())
        ) {
            const EXTRA = this.extra(mark);
            return CHECK_VERSION(
                5,
                "Async with statements are",
                new astnodes.AsyncWith(a, b, pegen.NEW_TYPE_COMMENT(this, tc), ...EXTRA)
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    with_item(): withitem | null {
        // with_item: expression 'as' star_target &(',' | ')' | ':') | invalid_with_item | expression
        let e, invalid_with_item, keyword, t;
        const mark = this.mark();
        if (
            (e = this.expression()) &&
            (keyword = this.expect("as")) &&
            (t = this.star_target()) &&
            this.positive_lookahead(this._tmp_47)
        ) {
            return new astnodes.withitem(e, t);
        }
        this.reset(mark);
        if ((invalid_with_item = this.invalid_with_item())) {
            return invalid_with_item;
        }
        this.reset(mark);
        if ((e = this.expression())) {
            return new astnodes.withitem(e, null);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    try_stmt(): stmt | null {
        // try_stmt: 'try' ':' block finally_block | 'try' ':' block except_block+ else_block? finally_block?
        let b, el, ex, f, keyword, literal;
        const mark = this.mark();
        if (
            (keyword = this.expect("try")) &&
            (literal = this.expect(":")) &&
            (b = this.block()) &&
            (f = this.finally_block())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Try(b, null, null, f, ...EXTRA);
        }
        this.reset(mark);
        if (
            (keyword = this.expect("try")) &&
            (literal = this.expect(":")) &&
            (b = this.block()) &&
            (ex = this._loop1_48()) &&
            ((el = this.else_block()), 1) &&
            ((f = this.finally_block()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Try(b, ex, el, f, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    except_block(): excepthandler | null {
        // except_block: 'except' expression ['as' NAME] ':' block | 'except' ':' block
        let b, e, keyword, literal, t;
        const mark = this.mark();
        if (
            (keyword = this.expect("except")) &&
            (e = this.expression()) &&
            ((t = this._tmp_49()), 1) &&
            (literal = this.expect(":")) &&
            (b = this.block())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.ExceptHandler(e, t ? t.id : null, b, ...EXTRA);
        }
        this.reset(mark);
        if ((keyword = this.expect("except")) && (literal = this.expect(":")) && (b = this.block())) {
            const EXTRA = this.extra(mark);
            return new astnodes.ExceptHandler(null, null, b, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    finally_block(): stmt[] | null {
        // finally_block: 'finally' ':' block
        let a, keyword, literal;
        const mark = this.mark();
        if ((keyword = this.expect("finally")) && (literal = this.expect(":")) && (a = this.block())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    return_stmt(): stmt | null {
        // return_stmt: 'return' star_expressions?
        let a, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("return")) && ((a = this.star_expressions()), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Return(a, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    raise_stmt(): stmt | null {
        // raise_stmt: 'raise' expression ['from' expression] | 'raise'
        let a, b, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("raise")) && (a = this.expression()) && ((b = this._tmp_50()), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Raise(a, b, ...EXTRA);
        }
        this.reset(mark);
        if ((keyword = this.expect("raise"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Raise(null, null, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    function_def(): FunctionDef | AsyncFunctionDef | null {
        // function_def: decorators function_def_raw | function_def_raw
        let d, f, function_def_raw;
        const mark = this.mark();
        if ((d = this.decorators()) && (f = this.function_def_raw())) {
            return pegen.function_def_decorators(this, d, f);
        }
        this.reset(mark);
        if ((function_def_raw = this.function_def_raw())) {
            return function_def_raw;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    function_def_raw(): FunctionDef | AsyncFunctionDef | null {
        // function_def_raw: 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block | ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
        let a, async, b, keyword, literal, literal_1, literal_2, n, params, tc;
        const mark = this.mark();
        if (
            (keyword = this.expect("def")) &&
            (n = this.name()) &&
            (literal = this.expect("(")) &&
            ((params = this.params()), 1) &&
            (literal_1 = this.expect(")")) &&
            ((a = this._tmp_51()), 1) &&
            (literal_2 = this.expect(":")) &&
            ((tc = this.func_type_comment()), 1) &&
            (b = this.block())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.FunctionDef(
                n.id,
                params ? params : CHECK(pegen.empty_arguments(this)),
                b,
                null,
                a,
                pegen.NEW_TYPE_COMMENT(this, tc),
                ...EXTRA
            );
        }
        this.reset(mark);
        if (
            (async = this.expect("ASYNC")) &&
            (keyword = this.expect("def")) &&
            (n = this.name()) &&
            (literal = this.expect("(")) &&
            ((params = this.params()), 1) &&
            (literal_1 = this.expect(")")) &&
            ((a = this._tmp_52()), 1) &&
            (literal_2 = this.expect(":")) &&
            ((tc = this.func_type_comment()), 1) &&
            (b = this.block())
        ) {
            const EXTRA = this.extra(mark);
            return CHECK_VERSION(
                5,
                "Async functions are",
                new astnodes.AsyncFunctionDef(
                    n.id,
                    params ? params : CHECK(pegen.empty_arguments(this)),
                    b,
                    null,
                    a,
                    pegen.NEW_TYPE_COMMENT(this, tc),
                    ...EXTRA
                )
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    func_type_comment(): TokenInfo | null {
        // func_type_comment: NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | invalid_double_type_comments | TYPE_COMMENT
        let invalid_double_type_comments, newline, t, type_comment;
        const mark = this.mark();
        if (
            (newline = this.expect("NEWLINE")) &&
            (t = this.expect("TYPE_COMMENT")) &&
            this.positive_lookahead(this._tmp_53)
        ) {
            return t;
        }
        this.reset(mark);
        if ((invalid_double_type_comments = this.invalid_double_type_comments())) {
            return invalid_double_type_comments;
        }
        this.reset(mark);
        if ((type_comment = this.expect("TYPE_COMMENT"))) {
            return type_comment;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    params(): arguments_ | null {
        // params: invalid_parameters | parameters
        let invalid_parameters, parameters;
        const mark = this.mark();
        if ((invalid_parameters = this.invalid_parameters())) {
            return invalid_parameters;
        }
        this.reset(mark);
        if ((parameters = this.parameters())) {
            return parameters;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    parameters(): arguments_ | null {
        // parameters: slash_no_default param_no_default* param_with_default* star_etc? | slash_with_default param_with_default* star_etc? | param_no_default+ param_with_default* star_etc? | param_with_default+ star_etc? | star_etc
        let a, b, c, d;
        const mark = this.mark();
        if (
            (a = this.slash_no_default()) &&
            (b = this._loop0_54()) &&
            (c = this._loop0_55()) &&
            ((d = this.star_etc()), 1)
        ) {
            return pegen.make_arguments(this, a, null, b, c, d);
        }
        this.reset(mark);
        if ((a = this.slash_with_default()) && (b = this._loop0_56()) && ((c = this.star_etc()), 1)) {
            return pegen.make_arguments(this, null, a, null, b, c);
        }
        this.reset(mark);
        if ((a = this._loop1_57()) && (b = this._loop0_58()) && ((c = this.star_etc()), 1)) {
            return pegen.make_arguments(this, null, null, a, b, c);
        }
        this.reset(mark);
        if ((a = this._loop1_59()) && ((b = this.star_etc()), 1)) {
            return pegen.make_arguments(this, null, null, null, a, b);
        }
        this.reset(mark);
        if ((a = this.star_etc())) {
            return pegen.make_arguments(this, null, null, null, null, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    slash_no_default(): arg[] | null {
        // slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
        let a, literal, literal_1;
        const mark = this.mark();
        if ((a = this._loop1_60()) && (literal = this.expect("/")) && (literal_1 = this.expect(","))) {
            return a;
        }
        this.reset(mark);
        if ((a = this._loop1_61()) && (literal = this.expect("/")) && this.positive_lookahead(this.expect, ")")) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    slash_with_default(): SlashWithDefault | null {
        // slash_with_default: param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'
        let a, b, literal, literal_1;
        const mark = this.mark();
        if (
            (a = this._loop0_62()) &&
            (b = this._loop1_63()) &&
            (literal = this.expect("/")) &&
            (literal_1 = this.expect(","))
        ) {
            return new SlashWithDefault(a, b);
        }
        this.reset(mark);
        if (
            (a = this._loop0_64()) &&
            (b = this._loop1_65()) &&
            (literal = this.expect("/")) &&
            this.positive_lookahead(this.expect, ")")
        ) {
            return new SlashWithDefault(a, b);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_etc(): StarEtc | null {
        // star_etc: '*' param_no_default param_maybe_default* kwds? | '*' ',' param_maybe_default+ kwds? | kwds | invalid_star_etc
        let a, b, c, invalid_star_etc, literal, literal_1;
        const mark = this.mark();
        if (
            (literal = this.expect("*")) &&
            (a = this.param_no_default()) &&
            (b = this._loop0_66()) &&
            ((c = this.kwds()), 1)
        ) {
            return new StarEtc(a, b, c);
        }
        this.reset(mark);
        if (
            (literal = this.expect("*")) &&
            (literal_1 = this.expect(",")) &&
            (b = this._loop1_67()) &&
            ((c = this.kwds()), 1)
        ) {
            return new StarEtc(null, b, c);
        }
        this.reset(mark);
        if ((a = this.kwds())) {
            return new StarEtc(null, null, a);
        }
        this.reset(mark);
        if ((invalid_star_etc = this.invalid_star_etc())) {
            return invalid_star_etc;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    kwds(): arg | null {
        // kwds: '**' param_no_default
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect("**")) && (a = this.param_no_default())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    param_no_default(): arg | null {
        // param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
        let a, literal, tc;
        const mark = this.mark();
        if ((a = this.param()) && (literal = this.expect(",")) && ((tc = this.expect("TYPE_COMMENT")), 1)) {
            return pegen.add_type_comment_to_arg(this, a, tc);
        }
        this.reset(mark);
        if (
            (a = this.param()) &&
            ((tc = this.expect("TYPE_COMMENT")), 1) &&
            this.positive_lookahead(this.expect, ")")
        ) {
            return pegen.add_type_comment_to_arg(this, a, tc);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    param_with_default(): NameDefaultPair<expr> | null {
        // param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
        let a, c, literal, tc;
        const mark = this.mark();
        if (
            (a = this.param()) &&
            (c = this.default()) &&
            (literal = this.expect(",")) &&
            ((tc = this.expect("TYPE_COMMENT")), 1)
        ) {
            return pegen.name_default_pair(this, a, c, tc);
        }
        this.reset(mark);
        if (
            (a = this.param()) &&
            (c = this.default()) &&
            ((tc = this.expect("TYPE_COMMENT")), 1) &&
            this.positive_lookahead(this.expect, ")")
        ) {
            return pegen.name_default_pair(this, a, c, tc);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    param_maybe_default(): NameDefaultPair | null {
        // param_maybe_default: param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')'
        let a, c, literal, tc;
        const mark = this.mark();
        if (
            (a = this.param()) &&
            ((c = this.default()), 1) &&
            (literal = this.expect(",")) &&
            ((tc = this.expect("TYPE_COMMENT")), 1)
        ) {
            return pegen.name_default_pair(this, a, c, tc);
        }
        this.reset(mark);
        if (
            (a = this.param()) &&
            ((c = this.default()), 1) &&
            ((tc = this.expect("TYPE_COMMENT")), 1) &&
            this.positive_lookahead(this.expect, ")")
        ) {
            return pegen.name_default_pair(this, a, c, tc);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    param(): arg | null {
        // param: NAME annotation?
        let a, b;
        const mark = this.mark();
        if ((a = this.name()) && ((b = this.annotation()), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.arg(a.id, b, null, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    annotation(): expr | null {
        // annotation: ':' expression
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect(":")) && (a = this.expression())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    default(): expr | null {
        // default: '=' expression
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect("=")) && (a = this.expression())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    decorators(): expr[] | null {
        // decorators: (('@' named_expression NEWLINE))+
        let a;
        const mark = this.mark();
        if ((a = this._loop1_68())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    class_def(): ClassDef | null {
        // class_def: decorators class_def_raw | class_def_raw
        let a, b, class_def_raw;
        const mark = this.mark();
        if ((a = this.decorators()) && (b = this.class_def_raw())) {
            return pegen.class_def_decorators(this, a, b);
        }
        this.reset(mark);
        if ((class_def_raw = this.class_def_raw())) {
            return class_def_raw;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    class_def_raw(): ClassDef | null {
        // class_def_raw: 'class' NAME ['(' arguments_? ')'] ':' block
        let a, b, c, keyword, literal;
        const mark = this.mark();
        if (
            (keyword = this.expect("class")) &&
            (a = this.name()) &&
            ((b = this._tmp_69()), 1) &&
            (literal = this.expect(":")) &&
            (c = this.block())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.ClassDef(a.id, b ? b.args : null, b ? b.keywords : null, c, null, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    block(): stmt[] | null {
        // block: NEWLINE INDENT statements DEDENT | simple_stmt | invalid_block
        let a, dedent, indent, invalid_block, newline, simple_stmt;
        const mark = this.mark();
        if (
            (newline = this.expect("NEWLINE")) &&
            (indent = this.expect("INDENT")) &&
            (a = this.statements()) &&
            (dedent = this.expect("DEDENT"))
        ) {
            return a;
        }
        this.reset(mark);
        if ((simple_stmt = this.simple_stmt())) {
            return simple_stmt;
        }
        this.reset(mark);
        if ((invalid_block = this.invalid_block())) {
            return invalid_block;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_expressions(): expr | null {
        // star_expressions: star_expression ((',' star_expression))+ ','? | star_expression ',' | star_expression
        let a, b, literal, opt, star_expression;
        const mark = this.mark();
        if ((a = this.star_expression()) && (b = this._loop1_70()) && ((opt = this.expect(",")), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(CHECK(pegen.seq_insert_in_front(this, a, b)), astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.star_expression()) && (literal = this.expect(","))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(CHECK(pegen.singleton_seq(this, a)), astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((star_expression = this.star_expression())) {
            return star_expression;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_expression(): expr | null {
        // star_expression: '*' bitwise_or | expression
        let a, expression, literal;
        const mark = this.mark();
        if ((literal = this.expect("*")) && (a = this.bitwise_or())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Starred(a, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((expression = this.expression())) {
            return expression;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_named_expressions(): expr[] | null {
        // star_named_expressions: ','.star_named_expression+ ','?
        let a, opt;
        const mark = this.mark();
        if ((a = this._gather_71()) && ((opt = this.expect(",")), 1)) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_named_expression(): expr | null {
        // star_named_expression: '*' bitwise_or | named_expression
        let a, literal, named_expression;
        const mark = this.mark();
        if ((literal = this.expect("*")) && (a = this.bitwise_or())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Starred(a, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((named_expression = this.named_expression())) {
            return named_expression;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    named_expression(): expr | null {
        // named_expression: NAME ':=' ~ expression | expression !':=' | invalid_named_expression
        let a, b, expression, invalid_named_expression, literal;
        let cut = false;
        const mark = this.mark();
        if ((a = this.name()) && (literal = this.expect(":=")) && (cut = true) && (b = this.expression())) {
            const EXTRA = this.extra(mark);
            return new astnodes.NamedExpr(CHECK(pegen.set_expr_context(this, a, astnodes.Store)), b, ...EXTRA);
        }
        this.reset(mark);
        if (cut) return null;
        if ((expression = this.expression()) && this.negative_lookahead(this.expect, ":=")) {
            return expression;
        }
        this.reset(mark);
        if ((invalid_named_expression = this.invalid_named_expression())) {
            return invalid_named_expression;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    annotated_rhs(): expr | null {
        // annotated_rhs: yield_expr | star_expressions
        let star_expressions, yield_expr;
        const mark = this.mark();
        if ((yield_expr = this.yield_expr())) {
            return yield_expr;
        }
        this.reset(mark);
        if ((star_expressions = this.star_expressions())) {
            return star_expressions;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    expressions(): expr | null {
        // expressions: expression ((',' expression))+ ','? | expression ',' | expression
        let a, b, expression, literal, opt;
        const mark = this.mark();
        if ((a = this.expression()) && (b = this._loop1_73()) && ((opt = this.expect(",")), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(CHECK(pegen.seq_insert_in_front(this, a, b)), astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.expression()) && (literal = this.expect(","))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(CHECK(pegen.singleton_seq(this, a)), astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((expression = this.expression())) {
            return expression;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    expression(): expr | null {
        // expression: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
        let a, b, c, disjunction, keyword, keyword_1, lambdef;
        const mark = this.mark();
        if (
            (a = this.disjunction()) &&
            (keyword = this.expect("if")) &&
            (b = this.disjunction()) &&
            (keyword_1 = this.expect("else")) &&
            (c = this.expression())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.IfExp(b, a, c, ...EXTRA);
        }
        this.reset(mark);
        if ((disjunction = this.disjunction())) {
            return disjunction;
        }
        this.reset(mark);
        if ((lambdef = this.lambdef())) {
            return lambdef;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambdef(): expr | null {
        // lambdef: 'lambda' lambda_params? ':' expression
        let a, b, keyword, literal;
        const mark = this.mark();
        if (
            (keyword = this.expect("lambda")) &&
            ((a = this.lambda_params()), 1) &&
            (literal = this.expect(":")) &&
            (b = this.expression())
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Lambda(a ? a : CHECK(pegen.empty_arguments(this)), b, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_params(): arguments_ | null {
        // lambda_params: invalid_lambda_parameters | lambda_parameters
        let invalid_lambda_parameters, lambda_parameters;
        const mark = this.mark();
        if ((invalid_lambda_parameters = this.invalid_lambda_parameters())) {
            return invalid_lambda_parameters;
        }
        this.reset(mark);
        if ((lambda_parameters = this.lambda_parameters())) {
            return lambda_parameters;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_parameters(): arguments_ | null {
        // lambda_parameters: lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc? | lambda_slash_with_default lambda_param_with_default* lambda_star_etc? | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc? | lambda_param_with_default+ lambda_star_etc? | lambda_star_etc
        let a, b, c, d;
        const mark = this.mark();
        if (
            (a = this.lambda_slash_no_default()) &&
            (b = this._loop0_74()) &&
            (c = this._loop0_75()) &&
            ((d = this.lambda_star_etc()), 1)
        ) {
            return pegen.make_arguments(this, a, null, b, c, d);
        }
        this.reset(mark);
        if ((a = this.lambda_slash_with_default()) && (b = this._loop0_76()) && ((c = this.lambda_star_etc()), 1)) {
            return pegen.make_arguments(this, null, a, null, b, c);
        }
        this.reset(mark);
        if ((a = this._loop1_77()) && (b = this._loop0_78()) && ((c = this.lambda_star_etc()), 1)) {
            return pegen.make_arguments(this, null, null, a, b, c);
        }
        this.reset(mark);
        if ((a = this._loop1_79()) && ((b = this.lambda_star_etc()), 1)) {
            return pegen.make_arguments(this, null, null, null, a, b);
        }
        this.reset(mark);
        if ((a = this.lambda_star_etc())) {
            return pegen.make_arguments(this, null, null, null, null, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_slash_no_default(): arg[] | null {
        // lambda_slash_no_default: lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':'
        let a, literal, literal_1;
        const mark = this.mark();
        if ((a = this._loop1_80()) && (literal = this.expect("/")) && (literal_1 = this.expect(","))) {
            return a;
        }
        this.reset(mark);
        if ((a = this._loop1_81()) && (literal = this.expect("/")) && this.positive_lookahead(this.expect, ":")) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_slash_with_default(): SlashWithDefault | null {
        // lambda_slash_with_default: lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':'
        let a, b, literal, literal_1;
        const mark = this.mark();
        if (
            (a = this._loop0_82()) &&
            (b = this._loop1_83()) &&
            (literal = this.expect("/")) &&
            (literal_1 = this.expect(","))
        ) {
            return new SlashWithDefault(a, b);
        }
        this.reset(mark);
        if (
            (a = this._loop0_84()) &&
            (b = this._loop1_85()) &&
            (literal = this.expect("/")) &&
            this.positive_lookahead(this.expect, ":")
        ) {
            return new SlashWithDefault(a, b);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_star_etc(): StarEtc | null {
        // lambda_star_etc: '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds? | '*' ',' lambda_param_maybe_default+ lambda_kwds? | lambda_kwds | invalid_lambda_star_etc
        let a, b, c, invalid_lambda_star_etc, literal, literal_1;
        const mark = this.mark();
        if (
            (literal = this.expect("*")) &&
            (a = this.lambda_param_no_default()) &&
            (b = this._loop0_86()) &&
            ((c = this.lambda_kwds()), 1)
        ) {
            return new StarEtc(a, b, c);
        }
        this.reset(mark);
        if (
            (literal = this.expect("*")) &&
            (literal_1 = this.expect(",")) &&
            (b = this._loop1_87()) &&
            ((c = this.lambda_kwds()), 1)
        ) {
            return new StarEtc(null, b, c);
        }
        this.reset(mark);
        if ((a = this.lambda_kwds())) {
            return new StarEtc(null, null, a);
        }
        this.reset(mark);
        if ((invalid_lambda_star_etc = this.invalid_lambda_star_etc())) {
            return invalid_lambda_star_etc;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_kwds(): arg | null {
        // lambda_kwds: '**' lambda_param_no_default
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect("**")) && (a = this.lambda_param_no_default())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_param_no_default(): arg | null {
        // lambda_param_no_default: lambda_param ',' | lambda_param &':'
        let a, literal;
        const mark = this.mark();
        if ((a = this.lambda_param()) && (literal = this.expect(","))) {
            return a;
        }
        this.reset(mark);
        if ((a = this.lambda_param()) && this.positive_lookahead(this.expect, ":")) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_param_with_default(): NameDefaultPair<expr> | null {
        // lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
        let a, c, literal;
        const mark = this.mark();
        if ((a = this.lambda_param()) && (c = this.default()) && (literal = this.expect(","))) {
            return pegen.name_default_pair(this, a, c, null);
        }
        this.reset(mark);
        if ((a = this.lambda_param()) && (c = this.default()) && this.positive_lookahead(this.expect, ":")) {
            return pegen.name_default_pair(this, a, c, null);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_param_maybe_default(): NameDefaultPair | null {
        // lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
        let a, c, literal;
        const mark = this.mark();
        if ((a = this.lambda_param()) && ((c = this.default()), 1) && (literal = this.expect(","))) {
            return pegen.name_default_pair(this, a, c, null);
        }
        this.reset(mark);
        if ((a = this.lambda_param()) && ((c = this.default()), 1) && this.positive_lookahead(this.expect, ":")) {
            return pegen.name_default_pair(this, a, c, null);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lambda_param(): arg | null {
        // lambda_param: NAME
        let a;
        const mark = this.mark();
        if ((a = this.name())) {
            const EXTRA = this.extra(mark);
            return new astnodes.arg(a.id, null, null, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    disjunction(): expr | null {
        // disjunction: conjunction (('or' conjunction))+ | conjunction
        let a, b, conjunction;
        const mark = this.mark();
        if ((a = this.conjunction()) && (b = this._loop1_88())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BoolOp(astnodes.Or, CHECK(pegen.seq_insert_in_front(this, a, b)), ...EXTRA);
        }
        this.reset(mark);
        if ((conjunction = this.conjunction())) {
            return conjunction;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    conjunction(): expr | null {
        // conjunction: inversion (('and' inversion))+ | inversion
        let a, b, inversion;
        const mark = this.mark();
        if ((a = this.inversion()) && (b = this._loop1_89())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BoolOp(astnodes.And, CHECK(pegen.seq_insert_in_front(this, a, b)), ...EXTRA);
        }
        this.reset(mark);
        if ((inversion = this.inversion())) {
            return inversion;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    inversion(): expr | null {
        // inversion: 'not' inversion | comparison
        let a, comparison, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("not")) && (a = this.inversion())) {
            const EXTRA = this.extra(mark);
            return new astnodes.UnaryOp(astnodes.Not, a, ...EXTRA);
        }
        this.reset(mark);
        if ((comparison = this.comparison())) {
            return comparison;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    comparison(): expr | null {
        // comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        let a, b, bitwise_or;
        const mark = this.mark();
        if ((a = this.bitwise_or()) && (b = this._loop1_90())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Compare(
                a,
                CHECK(pegen.get_cmpops(this, b)),
                CHECK(pegen.get_exprs(this, b)),
                ...EXTRA
            );
        }
        this.reset(mark);
        if ((bitwise_or = this.bitwise_or())) {
            return bitwise_or;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    compare_op_bitwise_or_pair(): CmpopExprPair | null {
        // compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or
        let eq_bitwise_or,
            gt_bitwise_or,
            gte_bitwise_or,
            in_bitwise_or,
            is_bitwise_or,
            isnot_bitwise_or,
            lt_bitwise_or,
            lte_bitwise_or,
            noteq_bitwise_or,
            notin_bitwise_or;
        const mark = this.mark();
        if ((eq_bitwise_or = this.eq_bitwise_or())) {
            return eq_bitwise_or;
        }
        this.reset(mark);
        if ((noteq_bitwise_or = this.noteq_bitwise_or())) {
            return noteq_bitwise_or;
        }
        this.reset(mark);
        if ((lte_bitwise_or = this.lte_bitwise_or())) {
            return lte_bitwise_or;
        }
        this.reset(mark);
        if ((lt_bitwise_or = this.lt_bitwise_or())) {
            return lt_bitwise_or;
        }
        this.reset(mark);
        if ((gte_bitwise_or = this.gte_bitwise_or())) {
            return gte_bitwise_or;
        }
        this.reset(mark);
        if ((gt_bitwise_or = this.gt_bitwise_or())) {
            return gt_bitwise_or;
        }
        this.reset(mark);
        if ((notin_bitwise_or = this.notin_bitwise_or())) {
            return notin_bitwise_or;
        }
        this.reset(mark);
        if ((in_bitwise_or = this.in_bitwise_or())) {
            return in_bitwise_or;
        }
        this.reset(mark);
        if ((isnot_bitwise_or = this.isnot_bitwise_or())) {
            return isnot_bitwise_or;
        }
        this.reset(mark);
        if ((is_bitwise_or = this.is_bitwise_or())) {
            return is_bitwise_or;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    eq_bitwise_or(): CmpopExprPair | null {
        // eq_bitwise_or: '==' bitwise_or
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect("==")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.Eq, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    noteq_bitwise_or(): CmpopExprPair | null {
        // noteq_bitwise_or: ('!=') bitwise_or
        let a, tok;
        const mark = this.mark();
        if ((tok = this.expect("!=")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.NotEq, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lte_bitwise_or(): CmpopExprPair | null {
        // lte_bitwise_or: '<=' bitwise_or
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect("<=")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.LtE, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    lt_bitwise_or(): CmpopExprPair | null {
        // lt_bitwise_or: '<' bitwise_or
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect("<")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.Lt, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    gte_bitwise_or(): CmpopExprPair | null {
        // gte_bitwise_or: '>=' bitwise_or
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect(">=")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.GtE, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    gt_bitwise_or(): CmpopExprPair | null {
        // gt_bitwise_or: '>' bitwise_or
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect(">")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.Gt, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    notin_bitwise_or(): CmpopExprPair | null {
        // notin_bitwise_or: 'not' 'in' bitwise_or
        let a, keyword, keyword_1;
        const mark = this.mark();
        if ((keyword = this.expect("not")) && (keyword_1 = this.expect("in")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.NotIn, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    in_bitwise_or(): CmpopExprPair | null {
        // in_bitwise_or: 'in' bitwise_or
        let a, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("in")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.In, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    isnot_bitwise_or(): CmpopExprPair | null {
        // isnot_bitwise_or: 'is' 'not' bitwise_or
        let a, keyword, keyword_1;
        const mark = this.mark();
        if ((keyword = this.expect("is")) && (keyword_1 = this.expect("not")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.IsNot, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    is_bitwise_or(): CmpopExprPair | null {
        // is_bitwise_or: 'is' bitwise_or
        let a, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("is")) && (a = this.bitwise_or())) {
            return new CmpopExprPair(astnodes.Is, a);
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    bitwise_or(): expr | null {
        // bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        let a, b, bitwise_xor, literal;
        const mark = this.mark();
        if ((a = this.bitwise_or()) && (literal = this.expect("|")) && (b = this.bitwise_xor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.BitOr, b, ...EXTRA);
        }
        this.reset(mark);
        if ((bitwise_xor = this.bitwise_xor())) {
            return bitwise_xor;
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    bitwise_xor(): expr | null {
        // bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        let a, b, bitwise_and, literal;
        const mark = this.mark();
        if ((a = this.bitwise_xor()) && (literal = this.expect("^")) && (b = this.bitwise_and())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.BitXor, b, ...EXTRA);
        }
        this.reset(mark);
        if ((bitwise_and = this.bitwise_and())) {
            return bitwise_and;
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    bitwise_and(): expr | null {
        // bitwise_and: bitwise_and '&' shift_expr | shift_expr
        let a, b, literal, shift_expr;
        const mark = this.mark();
        if ((a = this.bitwise_and()) && (literal = this.expect("&")) && (b = this.shift_expr())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.BitAnd, b, ...EXTRA);
        }
        this.reset(mark);
        if ((shift_expr = this.shift_expr())) {
            return shift_expr;
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    shift_expr(): expr | null {
        // shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        let a, b, literal, sum;
        const mark = this.mark();
        if ((a = this.shift_expr()) && (literal = this.expect("<<")) && (b = this.sum())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.LShift, b, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.shift_expr()) && (literal = this.expect(">>")) && (b = this.sum())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.RShift, b, ...EXTRA);
        }
        this.reset(mark);
        if ((sum = this.sum())) {
            return sum;
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    sum(): expr | null {
        // sum: sum '+' term | sum '-' term | term
        let a, b, literal, term;
        const mark = this.mark();
        if ((a = this.sum()) && (literal = this.expect("+")) && (b = this.term())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.Add, b, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.sum()) && (literal = this.expect("-")) && (b = this.term())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.Sub, b, ...EXTRA);
        }
        this.reset(mark);
        if ((term = this.term())) {
            return term;
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    term(): expr | null {
        // term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        let a, b, factor, literal;
        const mark = this.mark();
        if ((a = this.term()) && (literal = this.expect("*")) && (b = this.factor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.Mult, b, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.term()) && (literal = this.expect("/")) && (b = this.factor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.Div, b, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.term()) && (literal = this.expect("//")) && (b = this.factor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.FloorDiv, b, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.term()) && (literal = this.expect("%")) && (b = this.factor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.Mod, b, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.term()) && (literal = this.expect("@")) && (b = this.factor())) {
            const EXTRA = this.extra(mark);
            return CHECK_VERSION(5, "The '@' operator is", new astnodes.BinOp(a, astnodes.MatMult, b, ...EXTRA));
        }
        this.reset(mark);
        if ((factor = this.factor())) {
            return factor;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    factor(): expr | null {
        // factor: '+' factor | '-' factor | '~' factor | power
        let a, literal, power;
        const mark = this.mark();
        if ((literal = this.expect("+")) && (a = this.factor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.UnaryOp(astnodes.UAdd, a, ...EXTRA);
        }
        this.reset(mark);
        if ((literal = this.expect("-")) && (a = this.factor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.UnaryOp(astnodes.USub, a, ...EXTRA);
        }
        this.reset(mark);
        if ((literal = this.expect("~")) && (a = this.factor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.UnaryOp(astnodes.Invert, a, ...EXTRA);
        }
        this.reset(mark);
        if ((power = this.power())) {
            return power;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    power(): expr | null {
        // power: await_primary '**' factor | await_primary
        let a, await_primary, b, literal;
        const mark = this.mark();
        if ((a = this.await_primary()) && (literal = this.expect("**")) && (b = this.factor())) {
            const EXTRA = this.extra(mark);
            return new astnodes.BinOp(a, astnodes.Pow, b, ...EXTRA);
        }
        this.reset(mark);
        if ((await_primary = this.await_primary())) {
            return await_primary;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    await_primary(): expr | null {
        // await_primary: AWAIT primary | primary
        let a, await_, primary;
        const mark = this.mark();
        if ((await_ = this.expect("AWAIT")) && (a = this.primary())) {
            const EXTRA = this.extra(mark);
            return CHECK_VERSION(5, "Await expressions are", new astnodes.Await(a, ...EXTRA));
        }
        this.reset(mark);
        if ((primary = this.primary())) {
            return primary;
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    primary(): expr | null {
        // primary: invalid_primary | primary '.' NAME | primary genexp | primary '(' arguments_? ')' | primary '[' slices ']' | atom
        let a, atom, b, invalid_primary, literal, literal_1;
        const mark = this.mark();
        if ((invalid_primary = this.invalid_primary())) {
            return invalid_primary;
        }
        this.reset(mark);
        if ((a = this.primary()) && (literal = this.expect(".")) && (b = this.name())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Attribute(a, b.id, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.primary()) && (b = this.genexp())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Call(a, CHECK(pegen.singleton_seq(this, b)), null, ...EXTRA);
        }
        this.reset(mark);
        if (
            (a = this.primary()) &&
            (literal = this.expect("(")) &&
            ((b = this.arguments_()), 1) &&
            (literal_1 = this.expect(")"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Call(a, b ? b.args : null, b ? b.keywords : null, ...EXTRA);
        }
        this.reset(mark);
        if (
            (a = this.primary()) &&
            (literal = this.expect("[")) &&
            (b = this.slices()) &&
            (literal_1 = this.expect("]"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Subscript(a, b, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((atom = this.atom())) {
            return atom;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    slices(): expr | null {
        // slices: slice !',' | ','.slice+ ','?
        let a, opt;
        const mark = this.mark();
        if ((a = this.slice()) && this.negative_lookahead(this.expect, ",")) {
            return a;
        }
        this.reset(mark);
        if ((a = this._gather_91()) && ((opt = this.expect(",")), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(a, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    slice(): expr | null {
        // slice: expression? ':' expression? [':' expression?] | expression
        let a, b, c, literal;
        const mark = this.mark();
        if (
            ((a = this.expression()), 1) &&
            (literal = this.expect(":")) &&
            ((b = this.expression()), 1) &&
            ((c = this._tmp_93()), 1)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Slice(a, b, c, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.expression())) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    atom(): expr | null {
        // atom: NAME | 'True' | 'False' | 'None' | '__peg_parser__' | &STRING strings | NUMBER | &'(' (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set | dictcomp | setcomp) | '...'
        let _tmp_94, _tmp_95, _tmp_96, keyword, literal, name, number, strings;
        const mark = this.mark();
        if ((name = this.name())) {
            return name;
        }
        this.reset(mark);
        if ((keyword = this.expect("True"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Constant(pyTrue, null, ...EXTRA);
        }
        this.reset(mark);
        if ((keyword = this.expect("False"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Constant(pyFalse, null, ...EXTRA);
        }
        this.reset(mark);
        if ((keyword = this.expect("None"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Constant(pyNone, null, ...EXTRA);
        }
        this.reset(mark);
        if ((keyword = this.expect("__peg_parser__"))) {
            return this.raise_error(pySyntaxError, "You found it!");
        }
        this.reset(mark);
        if (this.positive_lookahead(this.string) && (strings = this.strings())) {
            return strings;
        }
        this.reset(mark);
        if ((number = this.number())) {
            return number;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "(") && (_tmp_94 = this._tmp_94())) {
            return _tmp_94;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "[") && (_tmp_95 = this._tmp_95())) {
            return _tmp_95;
        }
        this.reset(mark);
        if (this.positive_lookahead(this.expect, "{") && (_tmp_96 = this._tmp_96())) {
            return _tmp_96;
        }
        this.reset(mark);
        if ((literal = this.expect("..."))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Constant(pyEllipsis, null, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    strings(): expr | null {
        // strings: STRING+
        let a;
        const mark = this.mark();
        if ((a = this._loop1_97())) {
            return pegen.concatenate_strings(this, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    list(): expr | null {
        // list: '[' star_named_expressions? ']'
        let a, literal, literal_1;
        const mark = this.mark();
        if (
            (literal = this.expect("[")) &&
            ((a = this.star_named_expressions()), 1) &&
            (literal_1 = this.expect("]"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.List(a, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    listcomp(): expr | null {
        // listcomp: '[' named_expression ~ for_if_clauses ']' | invalid_comprehension
        let a, b, invalid_comprehension, literal, literal_1;
        let cut = false;
        const mark = this.mark();
        if (
            (literal = this.expect("[")) &&
            (a = this.named_expression()) &&
            (cut = true) &&
            (b = this.for_if_clauses()) &&
            (literal_1 = this.expect("]"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.ListComp(a, b, ...EXTRA);
        }
        this.reset(mark);
        if (cut) return null;
        if ((invalid_comprehension = this.invalid_comprehension())) {
            return invalid_comprehension;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    tuple(): expr | null {
        // tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
        let a, literal, literal_1;
        const mark = this.mark();
        if ((literal = this.expect("(")) && ((a = this._tmp_98()), 1) && (literal_1 = this.expect(")"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(a, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    group(): expr | null {
        // group: '(' (yield_expr | named_expression) ')' | invalid_group
        let a, invalid_group, literal, literal_1;
        const mark = this.mark();
        if ((literal = this.expect("(")) && (a = this._tmp_99()) && (literal_1 = this.expect(")"))) {
            return a;
        }
        this.reset(mark);
        if ((invalid_group = this.invalid_group())) {
            return invalid_group;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    genexp(): expr | null {
        // genexp: '(' named_expression ~ for_if_clauses ')' | invalid_comprehension
        let a, b, invalid_comprehension, literal, literal_1;
        let cut = false;
        const mark = this.mark();
        if (
            (literal = this.expect("(")) &&
            (a = this.named_expression()) &&
            (cut = true) &&
            (b = this.for_if_clauses()) &&
            (literal_1 = this.expect(")"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.GeneratorExp(a, b, ...EXTRA);
        }
        this.reset(mark);
        if (cut) return null;
        if ((invalid_comprehension = this.invalid_comprehension())) {
            return invalid_comprehension;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    set(): expr | null {
        // set: '{' star_named_expressions '}'
        let a, literal, literal_1;
        const mark = this.mark();
        if ((literal = this.expect("{")) && (a = this.star_named_expressions()) && (literal_1 = this.expect("}"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Set(a, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    setcomp(): expr | null {
        // setcomp: '{' named_expression ~ for_if_clauses '}' | invalid_comprehension
        let a, b, invalid_comprehension, literal, literal_1;
        let cut = false;
        const mark = this.mark();
        if (
            (literal = this.expect("{")) &&
            (a = this.named_expression()) &&
            (cut = true) &&
            (b = this.for_if_clauses()) &&
            (literal_1 = this.expect("}"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.SetComp(a, b, ...EXTRA);
        }
        this.reset(mark);
        if (cut) return null;
        if ((invalid_comprehension = this.invalid_comprehension())) {
            return invalid_comprehension;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    dict(): expr | null {
        // dict: '{' double_starred_kvpairs? '}'
        let a, literal, literal_1;
        const mark = this.mark();
        if (
            (literal = this.expect("{")) &&
            ((a = this.double_starred_kvpairs()), 1) &&
            (literal_1 = this.expect("}"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Dict(CHECK(pegen.get_keys(this, a)), CHECK(pegen.get_values(this, a)), ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    dictcomp(): expr | null {
        // dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
        let a, b, invalid_dict_comprehension, literal, literal_1;
        const mark = this.mark();
        if (
            (literal = this.expect("{")) &&
            (a = this.kvpair()) &&
            (b = this.for_if_clauses()) &&
            (literal_1 = this.expect("}"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.DictComp(a.key, a.value, b, ...EXTRA);
        }
        this.reset(mark);
        if ((invalid_dict_comprehension = this.invalid_dict_comprehension())) {
            return invalid_dict_comprehension;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    double_starred_kvpairs(): KeyValuePair[] | null {
        // double_starred_kvpairs: ','.double_starred_kvpair+ ','?
        let a, opt;
        const mark = this.mark();
        if ((a = this._gather_100()) && ((opt = this.expect(",")), 1)) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    double_starred_kvpair(): KeyValuePair | null {
        // double_starred_kvpair: '**' bitwise_or | kvpair
        let a, kvpair, literal;
        const mark = this.mark();
        if ((literal = this.expect("**")) && (a = this.bitwise_or())) {
            return new KeyValuePair(null, a);
        }
        this.reset(mark);
        if ((kvpair = this.kvpair())) {
            return kvpair;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    kvpair(): KeyValuePair<expr> | null {
        // kvpair: expression ':' expression
        let a, b, literal;
        const mark = this.mark();
        if ((a = this.expression()) && (literal = this.expect(":")) && (b = this.expression())) {
            return new KeyValuePair(a, b);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    for_if_clauses(): comprehension[] | null {
        // for_if_clauses: for_if_clause+
        let _loop1_102;
        const mark = this.mark();
        if ((_loop1_102 = this._loop1_102())) {
            return _loop1_102;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    for_if_clause(): comprehension | null {
        // for_if_clause: ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | invalid_for_target
        let a, async, b, c, invalid_for_target, keyword, keyword_1;
        let cut = false;
        const mark = this.mark();
        if (
            (async = this.expect("ASYNC")) &&
            (keyword = this.expect("for")) &&
            (a = this.star_targets()) &&
            (keyword_1 = this.expect("in")) &&
            (cut = true) &&
            (b = this.disjunction()) &&
            (c = this._loop0_103())
        ) {
            return CHECK_VERSION(6, "Async comprehensions are", new astnodes.comprehension(a, b, c, 1));
        }
        this.reset(mark);
        if (cut) return null;
        if (
            (keyword = this.expect("for")) &&
            (a = this.star_targets()) &&
            (keyword_1 = this.expect("in")) &&
            (cut = true) &&
            (b = this.disjunction()) &&
            (c = this._loop0_104())
        ) {
            return new astnodes.comprehension(a, b, c, 0);
        }
        this.reset(mark);
        if (cut) return null;
        if ((invalid_for_target = this.invalid_for_target())) {
            return invalid_for_target;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    yield_expr(): expr | null {
        // yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
        let a, keyword, keyword_1;
        const mark = this.mark();
        if ((keyword = this.expect("yield")) && (keyword_1 = this.expect("from")) && (a = this.expression())) {
            const EXTRA = this.extra(mark);
            return new astnodes.YieldFrom(a, ...EXTRA);
        }
        this.reset(mark);
        if ((keyword = this.expect("yield")) && ((a = this.star_expressions()), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Yield(a, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    arguments_(): Call | null {
        // arguments_: args ','? &')' | invalid_arguments
        let a, invalid_arguments, opt;
        const mark = this.mark();
        if ((a = this.args()) && ((opt = this.expect(",")), 1) && this.positive_lookahead(this.expect, ")")) {
            return a;
        }
        this.reset(mark);
        if ((invalid_arguments = this.invalid_arguments())) {
            return invalid_arguments;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    args(): Call | null {
        // args: ','.(starred_expression | named_expression !'=')+ [',' kwargs] | kwargs
        let a, b;
        const mark = this.mark();
        if ((a = this._gather_105()) && ((b = this._tmp_107()), 1)) {
            const EXTRA = this.extra(mark);
            return pegen.collect_call_seqs(this, a, b, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.kwargs())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Call(
                pegen.dummy_name(this),
                CHECK_NULL_ALLOWED(pegen.seq_extract_starred_exprs(this, a)),
                CHECK_NULL_ALLOWED(pegen.seq_delete_starred_exprs(this, a)),
                ...EXTRA
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    kwargs(): KeywordOrStarred[] | null {
        // kwargs: ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+
        let _gather_112, _gather_114, a, b, literal;
        const mark = this.mark();
        if ((a = this._gather_108()) && (literal = this.expect(",")) && (b = this._gather_110())) {
            return pegen.join_sequences(this, a, b);
        }
        this.reset(mark);
        if ((_gather_112 = this._gather_112())) {
            return _gather_112;
        }
        this.reset(mark);
        if ((_gather_114 = this._gather_114())) {
            return _gather_114;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    starred_expression(): Starred | null {
        // starred_expression: '*' expression
        let a, literal;
        const mark = this.mark();
        if ((literal = this.expect("*")) && (a = this.expression())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Starred(a, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    kwarg_or_starred(): KeywordOrStarred | null {
        // kwarg_or_starred: NAME '=' expression | starred_expression | invalid_kwarg
        let a, b, invalid_kwarg, literal;
        const mark = this.mark();
        if ((a = this.name()) && (literal = this.expect("=")) && (b = this.expression())) {
            const EXTRA = this.extra(mark);
            return new KeywordOrStarred(CHECK(new astnodes.keyword(a.id, b, ...EXTRA)), true);
        }
        this.reset(mark);
        if ((a = this.starred_expression())) {
            return new KeywordOrStarred(a, false);
        }
        this.reset(mark);
        if ((invalid_kwarg = this.invalid_kwarg())) {
            return invalid_kwarg;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    kwarg_or_double_starred(): KeywordOrStarred | null {
        // kwarg_or_double_starred: NAME '=' expression | '**' expression | invalid_kwarg
        let a, b, invalid_kwarg, literal;
        const mark = this.mark();
        if ((a = this.name()) && (literal = this.expect("=")) && (b = this.expression())) {
            const EXTRA = this.extra(mark);
            return new KeywordOrStarred(CHECK(new astnodes.keyword(a.id, b, ...EXTRA)), true);
        }
        this.reset(mark);
        if ((literal = this.expect("**")) && (a = this.expression())) {
            const EXTRA = this.extra(mark);
            return new KeywordOrStarred(CHECK(new astnodes.keyword(null, a, ...EXTRA)), true);
        }
        this.reset(mark);
        if ((invalid_kwarg = this.invalid_kwarg())) {
            return invalid_kwarg;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_targets(): expr | null {
        // star_targets: star_target !',' | star_target ((',' star_target))* ','?
        let a, b, opt;
        const mark = this.mark();
        if ((a = this.star_target()) && this.negative_lookahead(this.expect, ",")) {
            return a;
        }
        this.reset(mark);
        if ((a = this.star_target()) && (b = this._loop0_116()) && ((opt = this.expect(",")), 1)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(CHECK(pegen.seq_insert_in_front(this, a, b)), astnodes.Store, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_targets_list_seq(): expr[] | null {
        // star_targets_list_seq: ','.star_target+ ','?
        let a, opt;
        const mark = this.mark();
        if ((a = this._gather_117()) && ((opt = this.expect(",")), 1)) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_targets_tuple_seq(): expr[] | null {
        // star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','
        let a, b, literal, opt;
        const mark = this.mark();
        if ((a = this.star_target()) && (b = this._loop1_119()) && ((opt = this.expect(",")), 1)) {
            return pegen.seq_insert_in_front(this, a, b);
        }
        this.reset(mark);
        if ((a = this.star_target()) && (literal = this.expect(","))) {
            return pegen.singleton_seq(this, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_target(): expr | null {
        // star_target: '*' (!'*' star_target) | target_with_star_atom
        let a, literal, target_with_star_atom;
        const mark = this.mark();
        if ((literal = this.expect("*")) && (a = this._tmp_120())) {
            const EXTRA = this.extra(mark);
            return new astnodes.Starred(
                CHECK(pegen.set_expr_context(this, a, astnodes.Store)),
                astnodes.Store,
                ...EXTRA
            );
        }
        this.reset(mark);
        if ((target_with_star_atom = this.target_with_star_atom())) {
            return target_with_star_atom;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    target_with_star_atom(): expr | null {
        // target_with_star_atom: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom
        let a, b, literal, literal_1, star_atom;
        const mark = this.mark();
        if (
            (a = this.t_primary()) &&
            (literal = this.expect(".")) &&
            (b = this.name()) &&
            this.negative_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Attribute(a, b.id, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);
        if (
            (a = this.t_primary()) &&
            (literal = this.expect("[")) &&
            (b = this.slices()) &&
            (literal_1 = this.expect("]")) &&
            this.negative_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Subscript(a, b, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);
        if ((star_atom = this.star_atom())) {
            return star_atom;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    star_atom(): expr | null {
        // star_atom: NAME | '(' target_with_star_atom ')' | '(' star_targets_tuple_seq? ')' | '[' star_targets_list_seq? ']'
        let a, literal, literal_1;
        const mark = this.mark();
        if ((a = this.name())) {
            return pegen.set_expr_context(this, a, astnodes.Store);
        }
        this.reset(mark);
        if ((literal = this.expect("(")) && (a = this.target_with_star_atom()) && (literal_1 = this.expect(")"))) {
            return pegen.set_expr_context(this, a, astnodes.Store);
        }
        this.reset(mark);
        if (
            (literal = this.expect("(")) &&
            ((a = this.star_targets_tuple_seq()), 1) &&
            (literal_1 = this.expect(")"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(a, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);
        if (
            (literal = this.expect("[")) &&
            ((a = this.star_targets_list_seq()), 1) &&
            (literal_1 = this.expect("]"))
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.List(a, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    single_target(): expr | null {
        // single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
        let a, literal, literal_1, single_subscript_attribute_target;
        const mark = this.mark();
        if ((single_subscript_attribute_target = this.single_subscript_attribute_target())) {
            return single_subscript_attribute_target;
        }
        this.reset(mark);
        if ((a = this.name())) {
            return pegen.set_expr_context(this, a, astnodes.Store);
        }
        this.reset(mark);
        if ((literal = this.expect("(")) && (a = this.single_target()) && (literal_1 = this.expect(")"))) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    single_subscript_attribute_target(): expr | null {
        // single_subscript_attribute_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead
        let a, b, literal, literal_1;
        const mark = this.mark();
        if (
            (a = this.t_primary()) &&
            (literal = this.expect(".")) &&
            (b = this.name()) &&
            this.negative_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Attribute(a, b.id, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);
        if (
            (a = this.t_primary()) &&
            (literal = this.expect("[")) &&
            (b = this.slices()) &&
            (literal_1 = this.expect("]")) &&
            this.negative_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Subscript(a, b, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    del_targets(): expr[] | null {
        // del_targets: ','.del_target+ ','?
        let a, opt;
        const mark = this.mark();
        if ((a = this._gather_121()) && ((opt = this.expect(",")), 1)) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    del_target(): expr | null {
        // del_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom
        let a, b, del_t_atom, literal, literal_1;
        const mark = this.mark();
        if (
            (a = this.t_primary()) &&
            (literal = this.expect(".")) &&
            (b = this.name()) &&
            this.negative_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Attribute(a, b.id, astnodes.Del, ...EXTRA);
        }
        this.reset(mark);
        if (
            (a = this.t_primary()) &&
            (literal = this.expect("[")) &&
            (b = this.slices()) &&
            (literal_1 = this.expect("]")) &&
            this.negative_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Subscript(a, b, astnodes.Del, ...EXTRA);
        }
        this.reset(mark);
        if ((del_t_atom = this.del_t_atom())) {
            return del_t_atom;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    del_t_atom(): expr | null {
        // del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
        let a, literal, literal_1;
        const mark = this.mark();
        if ((a = this.name())) {
            return pegen.set_expr_context(this, a, astnodes.Del);
        }
        this.reset(mark);
        if ((literal = this.expect("(")) && (a = this.del_target()) && (literal_1 = this.expect(")"))) {
            return pegen.set_expr_context(this, a, astnodes.Del);
        }
        this.reset(mark);
        if ((literal = this.expect("(")) && ((a = this.del_targets()), 1) && (literal_1 = this.expect(")"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(a, astnodes.Del, ...EXTRA);
        }
        this.reset(mark);
        if ((literal = this.expect("[")) && ((a = this.del_targets()), 1) && (literal_1 = this.expect("]"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.List(a, astnodes.Del, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    targets(): expr[] | null {
        // targets: ','.target+ ','?
        let a, opt;
        const mark = this.mark();
        if ((a = this._gather_123()) && ((opt = this.expect(",")), 1)) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    target(): expr | null {
        // target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | t_atom
        let a, b, literal, literal_1, t_atom;
        const mark = this.mark();
        if (
            (a = this.t_primary()) &&
            (literal = this.expect(".")) &&
            (b = this.name()) &&
            this.negative_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Attribute(a, b.id, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);
        if (
            (a = this.t_primary()) &&
            (literal = this.expect("[")) &&
            (b = this.slices()) &&
            (literal_1 = this.expect("]")) &&
            this.negative_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Subscript(a, b, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);
        if ((t_atom = this.t_atom())) {
            return t_atom;
        }
        this.reset(mark);

        return null;
    }

    @memoizeLeftRec
    t_primary(): expr | null {
        // t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' arguments_? ')' &t_lookahead | atom &t_lookahead
        let a, b, literal, literal_1;
        const mark = this.mark();
        if (
            (a = this.t_primary()) &&
            (literal = this.expect(".")) &&
            (b = this.name()) &&
            this.positive_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Attribute(a, b.id, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if (
            (a = this.t_primary()) &&
            (literal = this.expect("[")) &&
            (b = this.slices()) &&
            (literal_1 = this.expect("]")) &&
            this.positive_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Subscript(a, b, astnodes.Load, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.t_primary()) && (b = this.genexp()) && this.positive_lookahead(this.t_lookahead)) {
            const EXTRA = this.extra(mark);
            return new astnodes.Call(a, CHECK(pegen.singleton_seq(this, b)), null, ...EXTRA);
        }
        this.reset(mark);
        if (
            (a = this.t_primary()) &&
            (literal = this.expect("(")) &&
            ((b = this.arguments_()), 1) &&
            (literal_1 = this.expect(")")) &&
            this.positive_lookahead(this.t_lookahead)
        ) {
            const EXTRA = this.extra(mark);
            return new astnodes.Call(a, b ? b.args : null, b ? b.keywords : null, ...EXTRA);
        }
        this.reset(mark);
        if ((a = this.atom()) && this.positive_lookahead(this.t_lookahead)) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    t_lookahead(): TokenInfo | null {
        // t_lookahead: '(' | '[' | '.'
        let literal;
        const mark = this.mark();
        if ((literal = this.expect("("))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect("["))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect("."))) {
            return literal;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    t_atom(): expr | null {
        // t_atom: NAME | '(' target ')' | '(' targets? ')' | '[' targets? ']'
        let a, b, literal, literal_1;
        const mark = this.mark();
        if ((a = this.name())) {
            return pegen.set_expr_context(this, a, astnodes.Store);
        }
        this.reset(mark);
        if ((literal = this.expect("(")) && (a = this.target()) && (literal_1 = this.expect(")"))) {
            return pegen.set_expr_context(this, a, astnodes.Store);
        }
        this.reset(mark);
        if ((literal = this.expect("(")) && ((b = this.targets()), 1) && (literal_1 = this.expect(")"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.Tuple(b, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);
        if ((literal = this.expect("[")) && ((b = this.targets()), 1) && (literal_1 = this.expect("]"))) {
            const EXTRA = this.extra(mark);
            return new astnodes.List(b, astnodes.Store, ...EXTRA);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_arguments(): never | null {
        // invalid_arguments: args ',' '*' | expression for_if_clauses ',' [args | expression for_if_clauses] | args for_if_clauses | args ',' expression for_if_clauses | args ',' args
        let a, args, for_if_clauses, literal, literal_1, opt;
        const mark = this.mark();
        if ((args = this.args()) && (literal = this.expect(",")) && (literal_1 = this.expect("*"))) {
            return this.raise_error(pySyntaxError, "iterable argument unpacking follows keyword argument unpacking");
        }
        this.reset(mark);
        if (
            (a = this.expression()) &&
            (for_if_clauses = this.for_if_clauses()) &&
            (literal = this.expect(",")) &&
            ((opt = this._tmp_125()), 1)
        ) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "Generator expression must be parenthesized"
            );
        }
        this.reset(mark);
        if ((a = this.args()) && (for_if_clauses = this.for_if_clauses())) {
            return pegen.nonparen_genexp_in_call(this, a);
        }
        this.reset(mark);
        if (
            (args = this.args()) &&
            (literal = this.expect(",")) &&
            (a = this.expression()) &&
            (for_if_clauses = this.for_if_clauses())
        ) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "Generator expression must be parenthesized"
            );
        }
        this.reset(mark);
        if ((a = this.args()) && (literal = this.expect(",")) && (args = this.args())) {
            return pegen.arguments_parsing_error(this, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_kwarg(): never | null {
        // invalid_kwarg: expression '='
        let a, literal;
        const mark = this.mark();
        if ((a = this.expression()) && (literal = this.expect("="))) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                'expression cannot contain assignment, perhaps you meant "=="?'
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_named_expression(): never | null {
        // invalid_named_expression: expression ':=' expression
        let a, expression, literal;
        const mark = this.mark();
        if ((a = this.expression()) && (literal = this.expect(":=")) && (expression = this.expression())) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "cannot use assignment expressions with %s",
                pegen.get_expr_name(a)
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_assignment(): never | null {
        // invalid_assignment: invalid_ann_assign_target ':' expression | star_named_expression ',' star_named_expressions* ':' expression | expression ':' expression | ((star_targets '='))* star_expressions '=' | ((star_targets '='))* yield_expr '=' | star_expressions augassign (yield_expr | star_expressions)
        let _loop0_126, _loop0_127, _loop0_128, _tmp_129, a, augassign, expression, literal, literal_1;
        const mark = this.mark();
        if (
            (a = this.invalid_ann_assign_target()) &&
            (literal = this.expect(":")) &&
            (expression = this.expression())
        ) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "only single target (not %s) can be annotated",
                pegen.get_expr_name(a)
            );
        }
        this.reset(mark);
        if (
            (a = this.star_named_expression()) &&
            (literal = this.expect(",")) &&
            (_loop0_126 = this._loop0_126()) &&
            (literal_1 = this.expect(":")) &&
            (expression = this.expression())
        ) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "only single target (not tuple) can be annotated"
            );
        }
        this.reset(mark);
        if ((a = this.expression()) && (literal = this.expect(":")) && (expression = this.expression())) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "illegal target for annotation"
            );
        }
        this.reset(mark);
        if ((_loop0_127 = this._loop0_127()) && (a = this.star_expressions()) && (literal = this.expect("="))) {
            return this.raise_error_invalid_target(STAR_TARGETS, a);
        }
        this.reset(mark);
        if ((_loop0_128 = this._loop0_128()) && (a = this.yield_expr()) && (literal = this.expect("="))) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "assignment to yield expression not possible"
            );
        }
        this.reset(mark);
        if ((a = this.star_expressions()) && (augassign = this.augassign()) && (_tmp_129 = this._tmp_129())) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "'%s' is an illegal expression for augmented assignment",
                pegen.get_expr_name(a)
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_ann_assign_target(): expr | null {
        // invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
        let a, list, literal, literal_1, tuple;
        const mark = this.mark();
        if ((list = this.list())) {
            return list;
        }
        this.reset(mark);
        if ((tuple = this.tuple())) {
            return tuple;
        }
        this.reset(mark);
        if ((literal = this.expect("(")) && (a = this.invalid_ann_assign_target()) && (literal_1 = this.expect(")"))) {
            return a;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_del_stmt(): never | null {
        // invalid_del_stmt: 'del' star_expressions
        let a, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("del")) && (a = this.star_expressions())) {
            return this.raise_error_invalid_target(DEL_TARGETS, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_block(): never | null {
        // invalid_block: NEWLINE !INDENT
        let newline;
        const mark = this.mark();
        if ((newline = this.expect("NEWLINE")) && this.negative_lookahead(this.expect, "INDENT")) {
            return this.raise_error(pyIndentationError, "expected an indented block");
        }
        this.reset(mark);

        return null;
    }

    @logger
    invalid_primary(): never | null {
        // invalid_primary: primary '{'
        let a, primary;
        const mark = this.mark();
        if ((primary = this.primary()) && (a = this.expect("{"))) {
            return this.raise_error_known_location(pySyntaxError, a.lineno, a.col_offset + 1, "invalid syntax");
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_comprehension(): never | null {
        // invalid_comprehension: ('[' | '(' | '{') starred_expression for_if_clauses
        let _tmp_130, a, for_if_clauses;
        const mark = this.mark();
        if (
            (_tmp_130 = this._tmp_130()) &&
            (a = this.starred_expression()) &&
            (for_if_clauses = this.for_if_clauses())
        ) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "iterable unpacking cannot be used in comprehension"
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_dict_comprehension(): never | null {
        // invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
        let a, bitwise_or, for_if_clauses, literal, literal_1;
        const mark = this.mark();
        if (
            (literal = this.expect("{")) &&
            (a = this.expect("**")) &&
            (bitwise_or = this.bitwise_or()) &&
            (for_if_clauses = this.for_if_clauses()) &&
            (literal_1 = this.expect("}"))
        ) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "dict unpacking cannot be used in dict comprehension"
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_parameters(): never | null {
        // invalid_parameters: param_no_default* (slash_with_default | param_with_default+) param_no_default
        let _loop0_131, _tmp_132, param_no_default;
        const mark = this.mark();
        if (
            (_loop0_131 = this._loop0_131()) &&
            (_tmp_132 = this._tmp_132()) &&
            (param_no_default = this.param_no_default())
        ) {
            return this.raise_error(pySyntaxError, "non-default argument follows default argument");
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_lambda_parameters(): never | null {
        // invalid_lambda_parameters: lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default
        let _loop0_133, _tmp_134, lambda_param_no_default;
        const mark = this.mark();
        if (
            (_loop0_133 = this._loop0_133()) &&
            (_tmp_134 = this._tmp_134()) &&
            (lambda_param_no_default = this.lambda_param_no_default())
        ) {
            return this.raise_error(pySyntaxError, "non-default argument follows default argument");
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_star_etc(): never | null {
        // invalid_star_etc: '*' (')' | ',' (')' | '**')) | '*' ',' TYPE_COMMENT
        let _tmp_135, literal, literal_1, type_comment;
        const mark = this.mark();
        if ((literal = this.expect("*")) && (_tmp_135 = this._tmp_135())) {
            return this.raise_error(pySyntaxError, "named arguments must follow bare *");
        }
        this.reset(mark);
        if (
            (literal = this.expect("*")) &&
            (literal_1 = this.expect(",")) &&
            (type_comment = this.expect("TYPE_COMMENT"))
        ) {
            return this.raise_error(pySyntaxError, "bare * has associated type comment");
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_lambda_star_etc(): never | null {
        // invalid_lambda_star_etc: '*' (':' | ',' (':' | '**'))
        let _tmp_136, literal;
        const mark = this.mark();
        if ((literal = this.expect("*")) && (_tmp_136 = this._tmp_136())) {
            return this.raise_error(pySyntaxError, "named arguments must follow bare *");
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_double_type_comments(): never | null {
        // invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
        let indent, newline, newline_1, type_comment, type_comment_1;
        const mark = this.mark();
        if (
            (type_comment = this.expect("TYPE_COMMENT")) &&
            (newline = this.expect("NEWLINE")) &&
            (type_comment_1 = this.expect("TYPE_COMMENT")) &&
            (newline_1 = this.expect("NEWLINE")) &&
            (indent = this.expect("INDENT"))
        ) {
            return this.raise_error(pySyntaxError, "Cannot have two type comments on def");
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_with_item(): never | null {
        // invalid_with_item: expression 'as' expression
        let a, expression, keyword;
        const mark = this.mark();
        if ((expression = this.expression()) && (keyword = this.expect("as")) && (a = this.expression())) {
            return this.raise_error_invalid_target(STAR_TARGETS, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_for_target(): never | null {
        // invalid_for_target: ASYNC? 'for' star_expressions
        let a, keyword, opt;
        const mark = this.mark();
        if (((opt = this.expect("ASYNC")), 1) && (keyword = this.expect("for")) && (a = this.star_expressions())) {
            return this.raise_error_invalid_target(FOR_TARGETS, a);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_group(): never | null {
        // invalid_group: '(' starred_expression ')'
        let a, literal, literal_1;
        const mark = this.mark();
        if ((literal = this.expect("(")) && (a = this.starred_expression()) && (literal_1 = this.expect(")"))) {
            return this.raise_error_known_location(
                pySyntaxError,
                a.lineno,
                a.col_offset + 1,
                "can't use starred expression here"
            );
        }
        this.reset(mark);

        return null;
    }

    @memoize
    invalid_import_from_targets(): never | null {
        // invalid_import_from_targets: import_from_as_names ','
        let import_from_as_names, literal;
        const mark = this.mark();
        if ((import_from_as_names = this.import_from_as_names()) && (literal = this.expect(","))) {
            return this.raise_error(pySyntaxError, "trailing comma not allowed without surrounding parentheses");
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_1() {
        // _loop0_1: NEWLINE
        let newline;
        const children = [];
        let mark = this.mark();
        while ((newline = this.expect("NEWLINE"))) {
            children.push(newline);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_2() {
        // _loop0_2: NEWLINE
        let newline;
        const children = [];
        let mark = this.mark();
        while ((newline = this.expect("NEWLINE"))) {
            children.push(newline);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_4() {
        // _loop0_4: ',' expression
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.expression())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_3() {
        // _gather_3: expression _loop0_4
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.expression()) !== null && (seq = this._loop0_4()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_6() {
        // _loop0_6: ',' expression
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.expression())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_5() {
        // _gather_5: expression _loop0_6
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.expression()) !== null && (seq = this._loop0_6()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_8() {
        // _loop0_8: ',' expression
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.expression())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_7() {
        // _gather_7: expression _loop0_8
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.expression()) !== null && (seq = this._loop0_8()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_10() {
        // _loop0_10: ',' expression
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.expression())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_9() {
        // _gather_9: expression _loop0_10
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.expression()) !== null && (seq = this._loop0_10()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_11() {
        // _loop1_11: statement
        let statement;
        const children = [];
        let mark = this.mark();
        while ((statement = this.statement())) {
            children.push(statement);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_13() {
        // _loop0_13: ';' small_stmt
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(";")) && (elem = this.small_stmt())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_12() {
        // _gather_12: small_stmt _loop0_13
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.small_stmt()) !== null && (seq = this._loop0_13()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_14() {
        // _tmp_14: 'import' | 'from'
        let keyword;
        const mark = this.mark();
        if ((keyword = this.expect("import"))) {
            return keyword;
        }
        this.reset(mark);
        if ((keyword = this.expect("from"))) {
            return keyword;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_15() {
        // _tmp_15: 'def' | '@' | ASYNC
        let async, keyword, literal;
        const mark = this.mark();
        if ((keyword = this.expect("def"))) {
            return keyword;
        }
        this.reset(mark);
        if ((literal = this.expect("@"))) {
            return literal;
        }
        this.reset(mark);
        if ((async = this.expect("ASYNC"))) {
            return async;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_16() {
        // _tmp_16: 'class' | '@'
        let keyword, literal;
        const mark = this.mark();
        if ((keyword = this.expect("class"))) {
            return keyword;
        }
        this.reset(mark);
        if ((literal = this.expect("@"))) {
            return literal;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_17() {
        // _tmp_17: 'with' | ASYNC
        let async, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("with"))) {
            return keyword;
        }
        this.reset(mark);
        if ((async = this.expect("ASYNC"))) {
            return async;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_18() {
        // _tmp_18: 'for' | ASYNC
        let async, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("for"))) {
            return keyword;
        }
        this.reset(mark);
        if ((async = this.expect("ASYNC"))) {
            return async;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_19() {
        // _tmp_19: '=' annotated_rhs
        let d, literal;
        const mark = this.mark();
        if ((literal = this.expect("=")) && (d = this.annotated_rhs())) {
            return d;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_20() {
        // _tmp_20: '(' single_target ')' | single_subscript_attribute_target
        let b, literal, literal_1, single_subscript_attribute_target;
        const mark = this.mark();
        if ((literal = this.expect("(")) && (b = this.single_target()) && (literal_1 = this.expect(")"))) {
            return b;
        }
        this.reset(mark);
        if ((single_subscript_attribute_target = this.single_subscript_attribute_target())) {
            return single_subscript_attribute_target;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_21() {
        // _tmp_21: '=' annotated_rhs
        let d, literal;
        const mark = this.mark();
        if ((literal = this.expect("=")) && (d = this.annotated_rhs())) {
            return d;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_22() {
        // _loop1_22: (star_targets '=')
        let _tmp_137;
        const children = [];
        let mark = this.mark();
        while ((_tmp_137 = this._tmp_137())) {
            children.push(_tmp_137);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _tmp_23() {
        // _tmp_23: yield_expr | star_expressions
        let star_expressions, yield_expr;
        const mark = this.mark();
        if ((yield_expr = this.yield_expr())) {
            return yield_expr;
        }
        this.reset(mark);
        if ((star_expressions = this.star_expressions())) {
            return star_expressions;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_24() {
        // _tmp_24: yield_expr | star_expressions
        let star_expressions, yield_expr;
        const mark = this.mark();
        if ((yield_expr = this.yield_expr())) {
            return yield_expr;
        }
        this.reset(mark);
        if ((star_expressions = this.star_expressions())) {
            return star_expressions;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_26() {
        // _loop0_26: ',' NAME
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.name())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_25() {
        // _gather_25: NAME _loop0_26
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.name()) !== null && (seq = this._loop0_26()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_28() {
        // _loop0_28: ',' NAME
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.name())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_27() {
        // _gather_27: NAME _loop0_28
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.name()) !== null && (seq = this._loop0_28()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_29() {
        // _tmp_29: ',' expression
        let literal, z;
        const mark = this.mark();
        if ((literal = this.expect(",")) && (z = this.expression())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_30() {
        // _tmp_30: ';' | NEWLINE
        let literal, newline;
        const mark = this.mark();
        if ((literal = this.expect(";"))) {
            return literal;
        }
        this.reset(mark);
        if ((newline = this.expect("NEWLINE"))) {
            return newline;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_31() {
        // _loop0_31: ('.' | '...')
        let _tmp_138;
        const children = [];
        let mark = this.mark();
        while ((_tmp_138 = this._tmp_138())) {
            children.push(_tmp_138);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_32() {
        // _loop1_32: ('.' | '...')
        let _tmp_139;
        const children = [];
        let mark = this.mark();
        while ((_tmp_139 = this._tmp_139())) {
            children.push(_tmp_139);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_34() {
        // _loop0_34: ',' import_from_as_name
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.import_from_as_name())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_33() {
        // _gather_33: import_from_as_name _loop0_34
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.import_from_as_name()) !== null && (seq = this._loop0_34()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_35() {
        // _tmp_35: 'as' NAME
        let keyword, z;
        const mark = this.mark();
        if ((keyword = this.expect("as")) && (z = this.name())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_37() {
        // _loop0_37: ',' dotted_as_name
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.dotted_as_name())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_36() {
        // _gather_36: dotted_as_name _loop0_37
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.dotted_as_name()) !== null && (seq = this._loop0_37()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_38() {
        // _tmp_38: 'as' NAME
        let keyword, z;
        const mark = this.mark();
        if ((keyword = this.expect("as")) && (z = this.name())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_40() {
        // _loop0_40: ',' with_item
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.with_item())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_39() {
        // _gather_39: with_item _loop0_40
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.with_item()) !== null && (seq = this._loop0_40()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_42() {
        // _loop0_42: ',' with_item
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.with_item())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_41() {
        // _gather_41: with_item _loop0_42
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.with_item()) !== null && (seq = this._loop0_42()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_44() {
        // _loop0_44: ',' with_item
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.with_item())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_43() {
        // _gather_43: with_item _loop0_44
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.with_item()) !== null && (seq = this._loop0_44()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_46() {
        // _loop0_46: ',' with_item
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.with_item())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_45() {
        // _gather_45: with_item _loop0_46
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.with_item()) !== null && (seq = this._loop0_46()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_47() {
        // _tmp_47: ',' | ')' | ':'
        let literal;
        const mark = this.mark();
        if ((literal = this.expect(","))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect(")"))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect(":"))) {
            return literal;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_48() {
        // _loop1_48: except_block
        let except_block;
        const children = [];
        let mark = this.mark();
        while ((except_block = this.except_block())) {
            children.push(except_block);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _tmp_49() {
        // _tmp_49: 'as' NAME
        let keyword, z;
        const mark = this.mark();
        if ((keyword = this.expect("as")) && (z = this.name())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_50() {
        // _tmp_50: 'from' expression
        let keyword, z;
        const mark = this.mark();
        if ((keyword = this.expect("from")) && (z = this.expression())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_51() {
        // _tmp_51: '->' expression
        let literal, z;
        const mark = this.mark();
        if ((literal = this.expect("->")) && (z = this.expression())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_52() {
        // _tmp_52: '->' expression
        let literal, z;
        const mark = this.mark();
        if ((literal = this.expect("->")) && (z = this.expression())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_53() {
        // _tmp_53: NEWLINE INDENT
        let indent, newline;
        const mark = this.mark();
        if ((newline = this.expect("NEWLINE")) && (indent = this.expect("INDENT"))) {
            return [newline, indent];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_54() {
        // _loop0_54: param_no_default
        let param_no_default;
        const children = [];
        let mark = this.mark();
        while ((param_no_default = this.param_no_default())) {
            children.push(param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_55() {
        // _loop0_55: param_with_default
        let param_with_default;
        const children = [];
        let mark = this.mark();
        while ((param_with_default = this.param_with_default())) {
            children.push(param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_56() {
        // _loop0_56: param_with_default
        let param_with_default;
        const children = [];
        let mark = this.mark();
        while ((param_with_default = this.param_with_default())) {
            children.push(param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_57() {
        // _loop1_57: param_no_default
        let param_no_default;
        const children = [];
        let mark = this.mark();
        while ((param_no_default = this.param_no_default())) {
            children.push(param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_58() {
        // _loop0_58: param_with_default
        let param_with_default;
        const children = [];
        let mark = this.mark();
        while ((param_with_default = this.param_with_default())) {
            children.push(param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_59() {
        // _loop1_59: param_with_default
        let param_with_default;
        const children = [];
        let mark = this.mark();
        while ((param_with_default = this.param_with_default())) {
            children.push(param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_60() {
        // _loop1_60: param_no_default
        let param_no_default;
        const children = [];
        let mark = this.mark();
        while ((param_no_default = this.param_no_default())) {
            children.push(param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_61() {
        // _loop1_61: param_no_default
        let param_no_default;
        const children = [];
        let mark = this.mark();
        while ((param_no_default = this.param_no_default())) {
            children.push(param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_62() {
        // _loop0_62: param_no_default
        let param_no_default;
        const children = [];
        let mark = this.mark();
        while ((param_no_default = this.param_no_default())) {
            children.push(param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_63() {
        // _loop1_63: param_with_default
        let param_with_default;
        const children = [];
        let mark = this.mark();
        while ((param_with_default = this.param_with_default())) {
            children.push(param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_64() {
        // _loop0_64: param_no_default
        let param_no_default;
        const children = [];
        let mark = this.mark();
        while ((param_no_default = this.param_no_default())) {
            children.push(param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_65() {
        // _loop1_65: param_with_default
        let param_with_default;
        const children = [];
        let mark = this.mark();
        while ((param_with_default = this.param_with_default())) {
            children.push(param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_66() {
        // _loop0_66: param_maybe_default
        let param_maybe_default;
        const children = [];
        let mark = this.mark();
        while ((param_maybe_default = this.param_maybe_default())) {
            children.push(param_maybe_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_67() {
        // _loop1_67: param_maybe_default
        let param_maybe_default;
        const children = [];
        let mark = this.mark();
        while ((param_maybe_default = this.param_maybe_default())) {
            children.push(param_maybe_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_68() {
        // _loop1_68: ('@' named_expression NEWLINE)
        let _tmp_140;
        const children = [];
        let mark = this.mark();
        while ((_tmp_140 = this._tmp_140())) {
            children.push(_tmp_140);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _tmp_69() {
        // _tmp_69: '(' arguments_? ')'
        let literal, literal_1, z;
        const mark = this.mark();
        if ((literal = this.expect("(")) && ((z = this.arguments_()), 1) && (literal_1 = this.expect(")"))) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_70() {
        // _loop1_70: (',' star_expression)
        let _tmp_141;
        const children = [];
        let mark = this.mark();
        while ((_tmp_141 = this._tmp_141())) {
            children.push(_tmp_141);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_72() {
        // _loop0_72: ',' star_named_expression
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.star_named_expression())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_71() {
        // _gather_71: star_named_expression _loop0_72
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.star_named_expression()) !== null && (seq = this._loop0_72()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_73() {
        // _loop1_73: (',' expression)
        let _tmp_142;
        const children = [];
        let mark = this.mark();
        while ((_tmp_142 = this._tmp_142())) {
            children.push(_tmp_142);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_74() {
        // _loop0_74: lambda_param_no_default
        let lambda_param_no_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_no_default = this.lambda_param_no_default())) {
            children.push(lambda_param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_75() {
        // _loop0_75: lambda_param_with_default
        let lambda_param_with_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_with_default = this.lambda_param_with_default())) {
            children.push(lambda_param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_76() {
        // _loop0_76: lambda_param_with_default
        let lambda_param_with_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_with_default = this.lambda_param_with_default())) {
            children.push(lambda_param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_77() {
        // _loop1_77: lambda_param_no_default
        let lambda_param_no_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_no_default = this.lambda_param_no_default())) {
            children.push(lambda_param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_78() {
        // _loop0_78: lambda_param_with_default
        let lambda_param_with_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_with_default = this.lambda_param_with_default())) {
            children.push(lambda_param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_79() {
        // _loop1_79: lambda_param_with_default
        let lambda_param_with_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_with_default = this.lambda_param_with_default())) {
            children.push(lambda_param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_80() {
        // _loop1_80: lambda_param_no_default
        let lambda_param_no_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_no_default = this.lambda_param_no_default())) {
            children.push(lambda_param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_81() {
        // _loop1_81: lambda_param_no_default
        let lambda_param_no_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_no_default = this.lambda_param_no_default())) {
            children.push(lambda_param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_82() {
        // _loop0_82: lambda_param_no_default
        let lambda_param_no_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_no_default = this.lambda_param_no_default())) {
            children.push(lambda_param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_83() {
        // _loop1_83: lambda_param_with_default
        let lambda_param_with_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_with_default = this.lambda_param_with_default())) {
            children.push(lambda_param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_84() {
        // _loop0_84: lambda_param_no_default
        let lambda_param_no_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_no_default = this.lambda_param_no_default())) {
            children.push(lambda_param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_85() {
        // _loop1_85: lambda_param_with_default
        let lambda_param_with_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_with_default = this.lambda_param_with_default())) {
            children.push(lambda_param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_86() {
        // _loop0_86: lambda_param_maybe_default
        let lambda_param_maybe_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_maybe_default = this.lambda_param_maybe_default())) {
            children.push(lambda_param_maybe_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop1_87() {
        // _loop1_87: lambda_param_maybe_default
        let lambda_param_maybe_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_maybe_default = this.lambda_param_maybe_default())) {
            children.push(lambda_param_maybe_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_88() {
        // _loop1_88: ('or' conjunction)
        let _tmp_143;
        const children = [];
        let mark = this.mark();
        while ((_tmp_143 = this._tmp_143())) {
            children.push(_tmp_143);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_89() {
        // _loop1_89: ('and' inversion)
        let _tmp_144;
        const children = [];
        let mark = this.mark();
        while ((_tmp_144 = this._tmp_144())) {
            children.push(_tmp_144);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_90() {
        // _loop1_90: compare_op_bitwise_or_pair
        let compare_op_bitwise_or_pair;
        const children = [];
        let mark = this.mark();
        while ((compare_op_bitwise_or_pair = this.compare_op_bitwise_or_pair())) {
            children.push(compare_op_bitwise_or_pair);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_92() {
        // _loop0_92: ',' slice
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.slice())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_91() {
        // _gather_91: slice _loop0_92
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.slice()) !== null && (seq = this._loop0_92()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_93() {
        // _tmp_93: ':' expression?
        let d, literal;
        const mark = this.mark();
        if ((literal = this.expect(":")) && ((d = this.expression()), 1)) {
            return d;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_94() {
        // _tmp_94: tuple | group | genexp
        let genexp, group, tuple;
        const mark = this.mark();
        if ((tuple = this.tuple())) {
            return tuple;
        }
        this.reset(mark);
        if ((group = this.group())) {
            return group;
        }
        this.reset(mark);
        if ((genexp = this.genexp())) {
            return genexp;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_95() {
        // _tmp_95: list | listcomp
        let list, listcomp;
        const mark = this.mark();
        if ((list = this.list())) {
            return list;
        }
        this.reset(mark);
        if ((listcomp = this.listcomp())) {
            return listcomp;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_96() {
        // _tmp_96: dict | set | dictcomp | setcomp
        let dict, dictcomp, set, setcomp;
        const mark = this.mark();
        if ((dict = this.dict())) {
            return dict;
        }
        this.reset(mark);
        if ((set = this.set())) {
            return set;
        }
        this.reset(mark);
        if ((dictcomp = this.dictcomp())) {
            return dictcomp;
        }
        this.reset(mark);
        if ((setcomp = this.setcomp())) {
            return setcomp;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_97() {
        // _loop1_97: STRING
        let string;
        const children = [];
        let mark = this.mark();
        while ((string = this.string())) {
            children.push(string);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _tmp_98() {
        // _tmp_98: star_named_expression ',' star_named_expressions?
        let literal, y, z;
        const mark = this.mark();
        if (
            (y = this.star_named_expression()) &&
            (literal = this.expect(",")) &&
            ((z = this.star_named_expressions()), 1)
        ) {
            return pegen.seq_insert_in_front(this, y, z);
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_99() {
        // _tmp_99: yield_expr | named_expression
        let named_expression, yield_expr;
        const mark = this.mark();
        if ((yield_expr = this.yield_expr())) {
            return yield_expr;
        }
        this.reset(mark);
        if ((named_expression = this.named_expression())) {
            return named_expression;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_101() {
        // _loop0_101: ',' double_starred_kvpair
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.double_starred_kvpair())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_100() {
        // _gather_100: double_starred_kvpair _loop0_101
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.double_starred_kvpair()) !== null && (seq = this._loop0_101()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_102() {
        // _loop1_102: for_if_clause
        let for_if_clause;
        const children = [];
        let mark = this.mark();
        while ((for_if_clause = this.for_if_clause())) {
            children.push(for_if_clause);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop0_103() {
        // _loop0_103: ('if' disjunction)
        let _tmp_145;
        const children = [];
        let mark = this.mark();
        while ((_tmp_145 = this._tmp_145())) {
            children.push(_tmp_145);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_104() {
        // _loop0_104: ('if' disjunction)
        let _tmp_146;
        const children = [];
        let mark = this.mark();
        while ((_tmp_146 = this._tmp_146())) {
            children.push(_tmp_146);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_106() {
        // _loop0_106: ',' (starred_expression | named_expression !'=')
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this._tmp_147())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_105() {
        // _gather_105: (starred_expression | named_expression !'=') _loop0_106
        let elem, seq;
        const mark = this.mark();
        if ((elem = this._tmp_147()) !== null && (seq = this._loop0_106()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_107() {
        // _tmp_107: ',' kwargs
        let k, literal;
        const mark = this.mark();
        if ((literal = this.expect(",")) && (k = this.kwargs())) {
            return k;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_109() {
        // _loop0_109: ',' kwarg_or_starred
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.kwarg_or_starred())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_108() {
        // _gather_108: kwarg_or_starred _loop0_109
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.kwarg_or_starred()) !== null && (seq = this._loop0_109()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_111() {
        // _loop0_111: ',' kwarg_or_double_starred
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.kwarg_or_double_starred())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_110() {
        // _gather_110: kwarg_or_double_starred _loop0_111
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.kwarg_or_double_starred()) !== null && (seq = this._loop0_111()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_113() {
        // _loop0_113: ',' kwarg_or_starred
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.kwarg_or_starred())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_112() {
        // _gather_112: kwarg_or_starred _loop0_113
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.kwarg_or_starred()) !== null && (seq = this._loop0_113()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_115() {
        // _loop0_115: ',' kwarg_or_double_starred
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.kwarg_or_double_starred())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_114() {
        // _gather_114: kwarg_or_double_starred _loop0_115
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.kwarg_or_double_starred()) !== null && (seq = this._loop0_115()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_116() {
        // _loop0_116: (',' star_target)
        let _tmp_148;
        const children = [];
        let mark = this.mark();
        while ((_tmp_148 = this._tmp_148())) {
            children.push(_tmp_148);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_118() {
        // _loop0_118: ',' star_target
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.star_target())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_117() {
        // _gather_117: star_target _loop0_118
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.star_target()) !== null && (seq = this._loop0_118()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_119() {
        // _loop1_119: (',' star_target)
        let _tmp_149;
        const children = [];
        let mark = this.mark();
        while ((_tmp_149 = this._tmp_149())) {
            children.push(_tmp_149);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _tmp_120() {
        // _tmp_120: !'*' star_target
        let star_target;
        const mark = this.mark();
        if (this.negative_lookahead(this.expect, "*") && (star_target = this.star_target())) {
            return star_target;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_122() {
        // _loop0_122: ',' del_target
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.del_target())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_121() {
        // _gather_121: del_target _loop0_122
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.del_target()) !== null && (seq = this._loop0_122()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_124() {
        // _loop0_124: ',' target
        let elem, literal;
        const children = [];
        let mark = this.mark();
        while ((literal = this.expect(",")) && (elem = this.target())) {
            children.push(elem);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _gather_123() {
        // _gather_123: target _loop0_124
        let elem, seq;
        const mark = this.mark();
        if ((elem = this.target()) !== null && (seq = this._loop0_124()) !== null) {
            return [elem, ...seq];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_125() {
        // _tmp_125: args | expression for_if_clauses
        let args, expression, for_if_clauses;
        const mark = this.mark();
        if ((args = this.args())) {
            return args;
        }
        this.reset(mark);
        if ((expression = this.expression()) && (for_if_clauses = this.for_if_clauses())) {
            return [expression, for_if_clauses];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_126() {
        // _loop0_126: star_named_expressions
        let star_named_expressions;
        const children = [];
        let mark = this.mark();
        while ((star_named_expressions = this.star_named_expressions())) {
            children.push(star_named_expressions);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_127() {
        // _loop0_127: (star_targets '=')
        let _tmp_150;
        const children = [];
        let mark = this.mark();
        while ((_tmp_150 = this._tmp_150())) {
            children.push(_tmp_150);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _loop0_128() {
        // _loop0_128: (star_targets '=')
        let _tmp_151;
        const children = [];
        let mark = this.mark();
        while ((_tmp_151 = this._tmp_151())) {
            children.push(_tmp_151);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _tmp_129() {
        // _tmp_129: yield_expr | star_expressions
        let star_expressions, yield_expr;
        const mark = this.mark();
        if ((yield_expr = this.yield_expr())) {
            return yield_expr;
        }
        this.reset(mark);
        if ((star_expressions = this.star_expressions())) {
            return star_expressions;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_130() {
        // _tmp_130: '[' | '(' | '{'
        let literal;
        const mark = this.mark();
        if ((literal = this.expect("["))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect("("))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect("{"))) {
            return literal;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_131() {
        // _loop0_131: param_no_default
        let param_no_default;
        const children = [];
        let mark = this.mark();
        while ((param_no_default = this.param_no_default())) {
            children.push(param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _tmp_132() {
        // _tmp_132: slash_with_default | param_with_default+
        let _loop1_152, slash_with_default;
        const mark = this.mark();
        if ((slash_with_default = this.slash_with_default())) {
            return slash_with_default;
        }
        this.reset(mark);
        if ((_loop1_152 = this._loop1_152())) {
            return _loop1_152;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop0_133() {
        // _loop0_133: lambda_param_no_default
        let lambda_param_no_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_no_default = this.lambda_param_no_default())) {
            children.push(lambda_param_no_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children;
    }

    @memoize
    _tmp_134() {
        // _tmp_134: lambda_slash_with_default | lambda_param_with_default+
        let _loop1_153, lambda_slash_with_default;
        const mark = this.mark();
        if ((lambda_slash_with_default = this.lambda_slash_with_default())) {
            return lambda_slash_with_default;
        }
        this.reset(mark);
        if ((_loop1_153 = this._loop1_153())) {
            return _loop1_153;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_135() {
        // _tmp_135: ')' | ',' (')' | '**')
        let _tmp_154, literal;
        const mark = this.mark();
        if ((literal = this.expect(")"))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect(",")) && (_tmp_154 = this._tmp_154())) {
            return [literal, _tmp_154];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_136() {
        // _tmp_136: ':' | ',' (':' | '**')
        let _tmp_155, literal;
        const mark = this.mark();
        if ((literal = this.expect(":"))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect(",")) && (_tmp_155 = this._tmp_155())) {
            return [literal, _tmp_155];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_137() {
        // _tmp_137: star_targets '='
        let literal, z;
        const mark = this.mark();
        if ((z = this.star_targets()) && (literal = this.expect("="))) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_138() {
        // _tmp_138: '.' | '...'
        let literal;
        const mark = this.mark();
        if ((literal = this.expect("."))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect("..."))) {
            return literal;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_139() {
        // _tmp_139: '.' | '...'
        let literal;
        const mark = this.mark();
        if ((literal = this.expect("."))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect("..."))) {
            return literal;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_140() {
        // _tmp_140: '@' named_expression NEWLINE
        let f, literal, newline;
        const mark = this.mark();
        if ((literal = this.expect("@")) && (f = this.named_expression()) && (newline = this.expect("NEWLINE"))) {
            return f;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_141() {
        // _tmp_141: ',' star_expression
        let c, literal;
        const mark = this.mark();
        if ((literal = this.expect(",")) && (c = this.star_expression())) {
            return c;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_142() {
        // _tmp_142: ',' expression
        let c, literal;
        const mark = this.mark();
        if ((literal = this.expect(",")) && (c = this.expression())) {
            return c;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_143() {
        // _tmp_143: 'or' conjunction
        let c, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("or")) && (c = this.conjunction())) {
            return c;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_144() {
        // _tmp_144: 'and' inversion
        let c, keyword;
        const mark = this.mark();
        if ((keyword = this.expect("and")) && (c = this.inversion())) {
            return c;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_145() {
        // _tmp_145: 'if' disjunction
        let keyword, z;
        const mark = this.mark();
        if ((keyword = this.expect("if")) && (z = this.disjunction())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_146() {
        // _tmp_146: 'if' disjunction
        let keyword, z;
        const mark = this.mark();
        if ((keyword = this.expect("if")) && (z = this.disjunction())) {
            return z;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_147() {
        // _tmp_147: starred_expression | named_expression !'='
        let named_expression, starred_expression;
        const mark = this.mark();
        if ((starred_expression = this.starred_expression())) {
            return starred_expression;
        }
        this.reset(mark);
        if ((named_expression = this.named_expression()) && this.negative_lookahead(this.expect, "=")) {
            return named_expression;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_148() {
        // _tmp_148: ',' star_target
        let c, literal;
        const mark = this.mark();
        if ((literal = this.expect(",")) && (c = this.star_target())) {
            return c;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_149() {
        // _tmp_149: ',' star_target
        let c, literal;
        const mark = this.mark();
        if ((literal = this.expect(",")) && (c = this.star_target())) {
            return c;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_150() {
        // _tmp_150: star_targets '='
        let literal, star_targets;
        const mark = this.mark();
        if ((star_targets = this.star_targets()) && (literal = this.expect("="))) {
            return [star_targets, literal];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_151() {
        // _tmp_151: star_targets '='
        let literal, star_targets;
        const mark = this.mark();
        if ((star_targets = this.star_targets()) && (literal = this.expect("="))) {
            return [star_targets, literal];
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _loop1_152() {
        // _loop1_152: param_with_default
        let param_with_default;
        const children = [];
        let mark = this.mark();
        while ((param_with_default = this.param_with_default())) {
            children.push(param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _loop1_153() {
        // _loop1_153: lambda_param_with_default
        let lambda_param_with_default;
        const children = [];
        let mark = this.mark();
        while ((lambda_param_with_default = this.lambda_param_with_default())) {
            children.push(lambda_param_with_default);
            mark = this.mark();
        }
        this.reset(mark);

        return children.length ? children : null;
    }

    @memoize
    _tmp_154() {
        // _tmp_154: ')' | '**'
        let literal;
        const mark = this.mark();
        if ((literal = this.expect(")"))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect("**"))) {
            return literal;
        }
        this.reset(mark);

        return null;
    }

    @memoize
    _tmp_155() {
        // _tmp_155: ':' | '**'
        let literal;
        const mark = this.mark();
        if ((literal = this.expect(":"))) {
            return literal;
        }
        this.reset(mark);
        if ((literal = this.expect("**"))) {
            return literal;
        }
        this.reset(mark);

        return null;
    }
}

GeneratedParser.prototype.keywords = new Map([
    ["return", new KeywordToken("return", 500)],
    ["raise", new KeywordToken("raise", 501)],
    ["pass", new KeywordToken("pass", 502)],
    ["del", new KeywordToken("del", 503)],
    ["yield", new KeywordToken("yield", 504)],
    ["assert", new KeywordToken("assert", 505)],
    ["break", new KeywordToken("break", 506)],
    ["continue", new KeywordToken("continue", 507)],
    ["global", new KeywordToken("global", 508)],
    ["nonlocal", new KeywordToken("nonlocal", 509)],
    ["if", new KeywordToken("if", 510)],
    ["try", new KeywordToken("try", 511)],
    ["while", new KeywordToken("while", 512)],
    ["import", new KeywordToken("import", 513)],
    ["from", new KeywordToken("from", 514)],
    ["elif", new KeywordToken("elif", 515)],
    ["else", new KeywordToken("else", 516)],
    ["for", new KeywordToken("for", 517)],
    ["in", new KeywordToken("in", 518)],
    ["with", new KeywordToken("with", 519)],
    ["as", new KeywordToken("as", 520)],
    ["except", new KeywordToken("except", 521)],
    ["finally", new KeywordToken("finally", 522)],
    ["def", new KeywordToken("def", 523)],
    ["class", new KeywordToken("class", 524)],
    ["lambda", new KeywordToken("lambda", 525)],
    ["not", new KeywordToken("not", 526)],
    ["is", new KeywordToken("is", 527)],
    ["True", new KeywordToken("True", 528)],
    ["False", new KeywordToken("False", 529)],
    ["None", new KeywordToken("None", 530)],
    ["__peg_parser__", new KeywordToken("__peg_parser__", 531)],
    ["or", new KeywordToken("or", 532)],
    ["and", new KeywordToken("and", 533)],
]);
